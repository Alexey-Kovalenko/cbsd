#!/usr/local/bin/cbsd
#v12.1.7
# Open task:
#  - why re@ at freebsd.org does not generate etcupdate files, e.g: https://download.freebsd.org/ftp/releases/amd64/12.1-RELEASE/
#  - why etcupdate used for source and destionation different presentations of the same hierarchy, e.g.
#     we can use -t for TGZ-archive while source tree cannot be an archive? the contents are the same!
#  - CBSD can generate result for etcupdate [extract|build] without source tree for old/new ver, from ~cbsd/basejail ?
#  - what we do with patch-level ? generate each time ?
#  - how can we facilitate pointing for from= and to= values/version? E.g, when etcupdate executed after version change, 
#    we can take/detect to= version automatically by elf from /bin/sh in jail (or take from= before update )
#    May be etcupdate should executed automatically with change/baseupdate/jupgrade script ? In this case we control old/new version
#  - create backup in ${jailsysdir}/${jname}/ ?
#  - extrnal etcupdate.conf file for custom excludes, e.g:
#      etcupdate_excludes="-I '/root/*' -I '/etc/hosts'" ?
MYARG="mode"
MYOPTARG="from to jname ver default_obtain_etcupdate_method force"
MYDESC="etcupdate helper, manage updates to system files not updated by installworld"
CBSDMODULE="jail"
ADDHELP="mode - extract,build,update,purge,resolve\n\
default_obtain_etcupdate_method= overwrite obtain method, valid: build,index\n\"
force=1 - force to extract/build even if resource already exist\n"

. ${subr}
. ${strings}
. ${distdir}/universe.subr
readconf buildworld.conf

. ${cbsdinit}

etcupdate_extract()
{
	# todo: generate from ~cbsd/basejail/* ? gen from etcupdate required for source tree!
	[ -z "${etcupdate_ver}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}ver=${N0_COLOR}"
	ver="${etcupdate_ver}"

	init_target_arch
	init_srcdir

	etcupdate_dir="${srcdir}/src_${ver}/etcupdate"

	if [ -d ${etcupdate_dir}/current ]; then
		if [ ${force} -eq 0 ]; then
			${ECHO} "${N1_COLOR}${CBSD_APP}: already exist: ${N2_COLOR}${etcupdate_dir}/current${N0_COLOR}"
			return 0
		fi
		${RM_CMD} -rf ${etcupdate_dir}/current
	fi

	case "${default_obtain_etcupdate_method}" in
		build)
			[ ! -r ${SRC_DIR}/Makefile ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such src hier in ${SRC_DIR}. Please run: ${N2_COLOR}cbsd srcup ver=${ver}${N1_COLOR} first${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: extract to: ${N2_COLOR}${etcupdate_dir}/current${N0_COLOR}"
			${ETCUPDATE_CMD} extract -d ${etcupdate_dir} -s ${SRC_DIR}
			[ ! -d ${etcupdate_dir}/current ] && err 1 "${N1_COLOR}${CBSD_APP} failed to extract: ${N1_COLOR}${etcupdate_dir}${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP} updated: ${N2_COLOR}${etcupdate_dir}${N0_COLOR}"
			;;
		index)
			index_ver="${ver}"
			index_file="${distsharedir}/etcupdate_${index_ver}.txt.xz"
			if [ ! -r ${index_file} ]; then
				# cut . in ver
				index_ver=${ver%%.*}
				index_file="${distsharedir}/etcupdate_${index_ver}.txt.xz"
			fi
			[ ! -r "${index_file}" ] && err 1 "${N1_COLOR}${CBSD_APP}: no index for default_obtain_etcupdate_method=index method: ${N2_COLOR}${index_file}${N0_COLOR}"
				over="${ver}"
			. ${buildconf}
			init_target_arch
			init_basedir

			if [ ! -x "${BASE_DIR}/bin/sh" ]; then
				${ECHO} "${N1_COLOR}${CBSD_APP}: no such base for default_obtain_etcupdate_method=index method: ${N2_COLOR}${BASE_DIR}${N0_COLOR}"
				err 1 "${N1_COLOR}${CBSD_APP}: please use: ${N2_COLOR}cbsd repo action=get source=base ver=${ver}${N0_COLOR}"
			fi

			[ -d ${etcupdate_dir}/current ] && ${RM_CMD} -rf ${etcupdate_dir}/current
			${ECHO} "${N1_COLOR}${CBSD_APP}: extract to: ${N2_COLOR}${etcupdate_dir}/current${N1_COLOR} (by: ${N2_COLOR}${index_file} <- ${BASE_DIR}${N1_COLOR})${N0_COLOR}"
			copy-binlib filelist=${index_file} dstdir=${etcupdate_dir}/current basedir=${BASE_DIR} 2>/dev/null
			;;
		*)
			err 1 "${N1_COLOR}${CBSD_APP}: unknown default_obtain_etcupdate_method: ${N2_COLOR}${default_obtain_etcupdate_method}${N0_COLOR}"
			;;
	esac
}

etcupdate_build()
{
	# todo: generate from ~cbsd/basejail/* ? gen from etcupdate required for source tree!
	[ -z "${etcupdate_ver}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}ver=${N0_COLOR}"
	ver="${etcupdate_ver}"

	init_target_arch
	init_srcdir

	etcupdate_dir="${srcdir}/src_${ver}/etcupdate"

	if [ ! -r ${etcupdate_dir}/etcupdate.tgz ]; then
		if [ ${force} -eq 0 ]; then
			${ECHO} "${N1_COLOR}${CBSD_APP}: already exist: ${N2_COLOR}${etcupdate_dir}/etcupdate.tgz${N0_COLOR}"
			return 0
		fi
		${RM_CMD} -f ${etcupdate_dir}/etcupdate.tgz
	fi

	case "${default_obtain_etcupdate_method}" in
		build)
			[ ! -r ${SRC_DIR}/Makefile ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such src hier in ${SRC_DIR}. Please run: ${N2_COLOR}cbsd srcup ver=${ver}${N1_COLOR} first${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: ${N2_COLOR}build...${N0_COLOR}"
			${ETCUPDATE_CMD} build -s ${SRC_DIR} ${etcupdate_dir}/etcupdate.tgz
			if [ -r ${etcupdate_dir}/etcupdate.tgz ]; then
				# done
			else
				err 1 "${N1_COLOR}${CBSD_APP} failed: no ${N2_COLOR}${etcupdate_dir}/etcupdate.tgz${N0_COLOR}"
			fi
			;;
		index)
			[ ! -d ${etcupdate_dir}/current ] && etcupdate mode=extract ver=${ver}
			[ ! -d ${etcupdate_dir}/current ] && err 1 "${N1_COLOR}${CBSD_APP} no dir: ${N1_COLOR}${etcupdate_dir}/current${N1_COLOR}. please run: ${N2_COLOR}cbsd etcupdate mode=extract ver=${ver}${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: build to: ${N2_COLOR}${etcupdate_dir}/etcupdate.tgz${N1_COLOR} (from: ${N2_COLOR}${etcupdate_dir}/current${N1_COLOR})${N0_COLOR}"
			cd ${etcupdate_dir}/current
			${TAR_CMD} cfz ${etcupdate_dir}/etcupdate.tgz .
			[ ! -r ${etcupdate_dir}/etcupdate.tgz ] && err 1 "${N1_COLOR}${CBSD_APP} failed to build: ${N1_COLOR}${etcupdate_dir}/etcupdate.tgz${N0_COLOR}"
			;;
	esac
}

etcupdate_update()
{
	local _exclude_args=
	local i

	[ -z "${jname}" ] && log_err 1 "${N1_COLOR}Please set jset: ${N2_COLOR}jname${N0_COLOR}"
	. ${jrcconf}
	[ $? -eq 1 ] && log_err 1 "${N1_COLOR}${CBSD_APP}: no such jail: ${N2_COLOR}${jname}${N0_COLOR}"

	[ -z "${from}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}from=${N0_COLOR}"
	if [ -z "${to}" ]; then
		${ECHO} "${N1_COLOR}${CBSD_APP} ${N2_COLOR}to=${N1_COLOR} not specified, assume jail version: ${N2_COLOR}${jail_ver}${N0_COLOR}"
		to="${jail_ver}"
	fi

	ver="${from}"
	init_target_arch
	init_srcdir

	etcupdate_from_dir="${srcdir}/src_${ver}/etcupdate"
	if [ ! -d ${etcupdate_from_dir}/current ]; then
		${ECHO} "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}${etcupdate_from_dir}/current${N0_COLOR}"
		err 1 "${N1_COLOR}please run for init: ${N2_COLOR}cbsd etcupdate mode=extract ver=${ver}${N0_COLOR}"
	fi
	${ECHO} "${N1_COLOR}${CBSD_APP} source hier: ${N2_COLOR}${etcupdate_from_dir}/current${N0_COLOR}"

	ver="${to}"
	init_target_arch
	init_srcdir
	etcupdate_to_dir="${srcdir}/src_${ver}"

	if [ ! -r ${etcupdate_to_dir}/etcupdate.tgz ]; then
		err 1 "${N1_COLOR}${CBSD_APP} failed: no ${N2_COLOR}${etcupdate_to_dir}/etcupdate.tgz${N0_COLOR}"
	fi
	${ECHO} "${N1_COLOR}${CBSD_APP} destination hier: ${N2_COLOR}${etcupdate_to_dir}/etcupdate.tgz${N0_COLOR}"

	# autostart/stop?
	[ ${jid} -eq 0 ] && log_err 1 "${N1_COLOR}${CBSD_APP}jail not running: ${N2_COLOR}${jname}${N0_COLOR}"

	[ ! -d ${etcupdate_jail_root} ] && ${MKDIR_CMD} -p ${etcupdate_jail_root}
	# we need RW place for log? redefine log path and use nullfs in RO?
	[ ! -d ${etcupdate_jail_root}/current ] && ${CP_CMD} -a ${etcupdate_from_dir}/current ${etcupdate_jail_root}

	for i in ${etcupdate_exclude_path}; do
		_exclude_args="${_exclude_args} -I ${i}"
	done

	echo "${ETCUPDATE_CMD} -d ${etcupdate_jail_root} -t ${etcupdate_to_dir}/etcupdate.tgz -D ${path} ${_exclude_args} ${extra_etcupdate_flags}"
	${ETCUPDATE_CMD} -d ${etcupdate_jail_root} -t ${etcupdate_to_dir}/etcupdate.tgz -D ${path} ${_exclude_args} ${extra_etcupdate_flags}
}

etcupdate_resolve()
{
	[ -z "${jname}" ] && log_err 1 "${N1_COLOR}Please set jset: ${N2_COLOR}jname${N0_COLOR}"
	. ${jrcconf}
	[ $? -eq 1 ] && log_err 1 "${N1_COLOR}${CBSD_APP}: no such jail: ${N2_COLOR}${jname}${N0_COLOR}"

	etcupdate_from_dir="${srcdir}/src_${ver}/etcupdate"
	if [ ! -d ${etcupdate_from_dir}/current ]; then
		err 1 "${N1_COLOR}no such workdir, please run: ${N2_COLOR}cbsd etcupdate mode=update jname=${jname} from=${N0_COLOR}"
	fi
	${ECHO} "${N1_COLOR}${CBSD_APP} source hier: ${N2_COLOR}${etcupdate_from_dir}/current${N0_COLOR}"

	echo "${ETCUPDATE_CMD} resolve -d ${etcupdate_jail_root} -D ${path}"
	${ETCUPDATE_CMD} resolve -d ${etcupdate_jail_root} -D ${path}
}

odefault_obtain_etcupdate_method=
oforce=

[ -n "${default_obtain_etcupdate_method}" ] && odefault_obtain_etcupdate_method="${default_obtain_etcupdate_method}"
[ -n "${force}" ] && oforce="${force}"

readconf etcupdate.conf

[ -n "${odefault_obtain_etcupdate_method}" ] && default_obtain_etcupdate_method="${odefault_obtain_etcupdate_method}"
[ -n "${oforce}" ] && force="${oforce}"

# set defaults
[ -z "${force}" ] && force=0

etcupdate_ver="${ver}"

if [ -n "${jname}" ]; then
	. ${jrcconf}
	[ "${emulator}" = "bhyve" ] && err 1 "${N1_COLOR}Not for bhyve mode${N0_COLOR}"
	etcupdate_jail_root="${jailsysdir}/${jname}/etcupdate"
fi

jail_ver="${ver}"

case "${mode}" in
	extract)
		etcupdate_extract
		;;
	build)
		etcupdate_build
		;;
	update)
		etcupdate_update
		;;
	purge)
		[ -d ${etcupdate_jail_root} ] && ${RM_CMD} -rf ${etcupdate_jail_root}
		;;
	resolve)
		etcupdate_resolve
		;;
	*)
		err 1 "${N1_COLOR}${CBSD_APP} error: unknown mode: ${N2_COLOR}${mode}${N0_COLOR}"
		;;
esac

exit 0
