#!/usr/local/bin/cbsd
#v12.1.7
# Open task:
#  - why re@ at freebsd.org does not generate etcupdate files, e.g: https://download.freebsd.org/ftp/releases/amd64/12.1-RELEASE/
#  - why etcupdate used for source and destionation different presentations of the same hierarchy, e.g.
#     we can use -t for TGZ-archive while source tree cannot be an archive? the contents are the same!
#  - CBSD can generate result for etcupdate [extract|build] without source tree for old/new ver, from ~cbsd/basejail ?
#  - what we do with patch-level ? generate each time ?
#  - how can we facilitate pointing for from= and to= values/version? E.g, when etcupdate executed after version change, 
#    we can take/detect to= version automatically by elf from /bin/sh in jail (or take from= before update )
#    May be etcupdate should executed automatically with change/baseupdate/jupgrade script ? In this case we control old/new version
#  - create backup in ${jailsysdir}/${jname}/ ?
#  - extrnal etcupdate.conf file for custom excludes, e.g:
#      etcupdate_excludes="-I '/root/*' -I '/etc/hosts'" ?
MYARG="mode"
MYOPTARG="from to jname ver default_obtain_etcupdate_method force arch target_arch"
MYDESC="etcupdate helper, manage updates to system files not updated by installworld"
CBSDMODULE="jail"
ADDHELP="mode - extract,build,update,purge,resolve\n\
when mode=extract and jname is set, extract etc files for specified jail\n\
default_obtain_etcupdate_method= overwrite obtain method, valid: build,index\n\
force=1 - force to extract/build even if resource already exist\n"

arch=
target_arch=

. ${subr}
. ${strings}
. ${distdir}/universe.subr
readconf buildworld.conf

. ${cbsdinit}

[ -n "${target_arch}" ] && otarget_arch="${target_arch}"
[ -n "${arch}" ] && oarch="${arch}"

etcupdate_base_extract()
{
	local _etcupdate_dir _index_ver _index_file

	# todo: generate from ~cbsd/basejail/* ? gen from etcupdate required for source tree!
	[ -z "${etcupdate_ver}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}ver=${N0_COLOR}"
	ver="${etcupdate_ver}"

	init_target_arch
	init_srcdir

	_etcupdate_dir="${srcdir}/src_${ver}/etcupdate"

	if [ -d ${_etcupdate_dir}/current ]; then
		if [ ${force} -eq 0 ]; then
			${ECHO} "${N1_COLOR}${CBSD_APP}: already exist: ${N2_COLOR}${_etcupdate_dir}/current${N0_COLOR}"
			return 0
		fi
		${RM_CMD} -rf ${_etcupdate_dir}/current
	fi

	case "${default_obtain_etcupdate_method}" in
		build)
			[ ! -r ${SRC_DIR}/Makefile ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such src hier in ${SRC_DIR}. Please run: ${N2_COLOR}cbsd srcup ver=${ver}${N1_COLOR} first${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: extract to: ${N2_COLOR}${_etcupdate_dir}/current${N0_COLOR}"
			${ETCUPDATE_CMD} extract -d ${_etcupdate_dir} -s ${SRC_DIR}
			[ ! -d ${_etcupdate_dir}/current ] && err 1 "${N1_COLOR}${CBSD_APP} failed to extract: ${N1_COLOR}${_etcupdate_dir}${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP} updated: ${N2_COLOR}${_etcupdate_dir}${N0_COLOR}"
			;;
		index)
			_index_ver="${ver}"
			_index_file="${distsharedir}/etcupdate_${_index_ver}.txt.xz"
			if [ ! -r ${_index_file} ]; then
				# cut . in ver
				_index_ver=${ver%%.*}
				_index_file="${distsharedir}/etcupdate_${_index_ver}.txt.xz"
			fi
			[ ! -r "${_index_file}" ] && err 1 "${N1_COLOR}${CBSD_APP}: no index for default_obtain_etcupdate_method=index method: ${N2_COLOR}${_index_file}${N0_COLOR}"
			over="${ver}"
			. ${buildconf}
			init_target_arch
			init_basedir

			if [ ! -x "${BASE_DIR}/bin/sh" ]; then
				${ECHO} "${N1_COLOR}${CBSD_APP}: no such base for default_obtain_etcupdate_method=index method: ${N2_COLOR}${BASE_DIR}${N0_COLOR}"
				err 1 "${N1_COLOR}${CBSD_APP}: please use: ${N2_COLOR}cbsd repo action=get source=base ver=${ver}${N0_COLOR}"
			fi

			[ -d ${_etcupdate_dir}/current ] && ${RM_CMD} -rf ${_etcupdate_dir}/current
			${ECHO} "${N1_COLOR}${CBSD_APP}: extract to: ${N2_COLOR}${_etcupdate_dir}/current${N1_COLOR} (by: ${N2_COLOR}${_index_file} <- ${BASE_DIR}${N1_COLOR})${N0_COLOR}" 1>&2
			copy-binlib filelist=${_index_file} dstdir=${_etcupdate_dir}/current basedir=${BASE_DIR} 2>/dev/null
			;;
		*)
			err 1 "${N1_COLOR}${CBSD_APP}: unknown default_obtain_etcupdate_method: ${N2_COLOR}${default_obtain_etcupdate_method}${N0_COLOR}"
			;;
	esac

	return 0
}

etcupdate_jail_extract()
{
	local _etcupdate_dir _etcupdate_from_dir

	[ -z "${jail_ver}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}ver=${N0_COLOR}"
	[ -z "${jname}" ] && log_err 1 "${N1_COLOR}Please set jset: ${N2_COLOR}jname${N0_COLOR}"
	. ${jrcconf}
	[ $? -eq 1 ] && log_err 1 "${N1_COLOR}${CBSD_APP}: no such jail: ${N2_COLOR}${jname}${N0_COLOR}"

	_etcupdate_from_dir="${srcdir}/src_${ver}/etcupdate"
	if [ ! -d ${_etcupdate_from_dir}/current ]; then
		${ECHO} "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}${_etcupdate_from_dir}/current${N0_COLOR}"
		err 1 "${N1_COLOR}${CBSD_APP}: please run for init: ${N2_COLOR}cbsd etcupdate mode=extract ver=${ver}${N0_COLOR}"
	fi

	[ ! -d ${etcupdate_jail_root} ] && ${MKDIR_CMD} -p ${etcupdate_jail_root}

	if [ -d ${etcupdate_jail_root}/current ]; then
		[ ${force} -eq 0 ] && return 0
		${RM_CMD} -rf ${etcupdate_jail_root}/current
	fi

	[ ! -d ${etcupdate_jail_root}/current ] && ${CP_CMD} -a ${_etcupdate_from_dir}/current ${etcupdate_jail_root}

	# store original version
	[ ! -r ${etcupdate_jail_root}/ver ] && ${TOUCH_CMD} ${etcupdate_jail_root}/ver
	${SYSRC_CMD} -qf ${etcupdate_jail_root}/ver etcupdate_current_ver="${ver}" > /dev/null 2>&1

	return 0
}

etcupdate_base_build()
{
	local _etcupdate_dir=

	# todo: generate from ~cbsd/basejail/* ? gen from etcupdate required for source tree!
	[ -z "${etcupdate_ver}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}ver=${N0_COLOR}"
	ver="${etcupdate_ver}"

	init_target_arch
	init_srcdir

	_etcupdate_dir="${srcdir}/src_${ver}/etcupdate"

	if [ -r ${_etcupdate_dir}/etcupdate.tgz ]; then
		if [ ${force} -eq 0 ]; then
			${ECHO} "${N1_COLOR}${CBSD_APP}: already exist: ${N2_COLOR}${_etcupdate_dir}/etcupdate.tgz${N0_COLOR}"
			return 0
		fi
		${RM_CMD} -f ${_etcupdate_dir}/etcupdate.tgz
	fi

	case "${default_obtain_etcupdate_method}" in
		build)
			[ ! -r ${SRC_DIR}/Makefile ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such src hier in ${SRC_DIR}. Please run: ${N2_COLOR}cbsd srcup ver=${ver}${N1_COLOR} first${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: ${N2_COLOR}build...${N0_COLOR}"
			${ETCUPDATE_CMD} build -s ${SRC_DIR} ${_etcupdate_dir}/etcupdate.tgz
			if [ -r ${_etcupdate_dir}/etcupdate.tgz ]; then
				# done
			else
				err 1 "${N1_COLOR}${CBSD_APP} failed: no ${N2_COLOR}${_etcupdate_dir}/etcupdate.tgz${N0_COLOR}"
			fi
			;;
		index)
			[ ! -d ${_etcupdate_dir}/current ] && etcupdate mode=extract ver=${ver}
			[ ! -d ${_etcupdate_dir}/current ] && err 1 "${N1_COLOR}${CBSD_APP} no dir: ${N1_COLOR}${_etcupdate_dir}/current${N1_COLOR}. please run: ${N2_COLOR}cbsd etcupdate mode=extract ver=${ver}${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: build to: ${N2_COLOR}${_etcupdate_dir}/etcupdate.tgz${N1_COLOR} (from: ${N2_COLOR}${_etcupdate_dir}/current${N1_COLOR})${N0_COLOR}"
			cd ${_etcupdate_dir}/current
			${TAR_CMD} cfz ${_etcupdate_dir}/etcupdate.tgz .
			[ ! -r ${_etcupdate_dir}/etcupdate.tgz ] && err 1 "${N1_COLOR}${CBSD_APP} failed to build: ${N1_COLOR}${_etcupdate_dir}/etcupdate.tgz${N0_COLOR}"
			;;
	esac

	return 0
}

etcupdate_update()
{
	local _exclude_args= i _ret
	local _files

	[ -z "${jname}" ] && log_err 1 "${N1_COLOR}${CBSD_APP}: please set jset: ${N2_COLOR}jname${N0_COLOR}"
	. ${jrcconf}
	[ $? -eq 1 ] && log_err 1 "${N1_COLOR}${CBSD_APP}: no such jail: ${N2_COLOR}${jname}${N0_COLOR}"

	if [ -z "${from}" ]; then
		if [ -r ${etcupdate_jail_root}/ver ]; then
			etcupdate_current_ver=
			. ${etcupdate_jail_root}/ver
			if [ -n "${etcupdate_current_ver}" ]; then
				from="${etcupdate_current_ver}"
				${ECHO} "${N1_COLOR}${CBSD_APP} ${N2_COLOR}from=${N1_COLOR} not specified, assume jail version: ${N2_COLOR}${from}${N0_COLOR}"
			fi
		fi
	fi
	[ -z "${from}" ] && err 1 "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}from=${N0_COLOR}"

	if [ -z "${to}" ]; then
		${ECHO} "${N1_COLOR}${CBSD_APP} ${N2_COLOR}to=${N1_COLOR} not specified, assume jail version: ${N2_COLOR}${jail_ver}${N0_COLOR}"
		to="${jail_ver}"
	fi

	ver="${from}"
	init_target_arch
	init_srcdir

	_etcupdate_from_dir="${srcdir}/src_${ver}/etcupdate"
	if [ ! -d ${_etcupdate_from_dir}/current ]; then
		${ECHO} "${N1_COLOR}${CBSD_APP} error: no such ${N2_COLOR}${_etcupdate_from_dir}/current${N0_COLOR}"
		err 1 "${N1_COLOR}${CBSD_APP}: please run for init: ${N2_COLOR}cbsd etcupdate mode=extract ver=${ver}${N0_COLOR}"
	fi
	${ECHO} "${N1_COLOR}${CBSD_APP} source hier: ${N2_COLOR}${_etcupdate_from_dir}/current${N0_COLOR}"

	ver="${to}"
	init_target_arch
	init_srcdir
	_etcupdate_to_dir="${srcdir}/src_${ver}/etcupdate"

	if [ ! -r ${_etcupdate_to_dir}/etcupdate.tgz ]; then
		${ECHO} "${N1_COLOR}${CBSD_APP} failed: no ${N2_COLOR}${_etcupdate_to_dir}/etcupdate.tgz${N0_COLOR}"
		err 1 "${N1_COLOR}${CBSD_APP}: please run for init: ${N2_COLOR}cbsd etcupdate mode=build ver=${ver}${N0_COLOR}"

	fi
	${ECHO} "${N1_COLOR}${CBSD_APP} destination hier: ${N2_COLOR}${_etcupdate_to_dir}/etcupdate.tgz${N0_COLOR}"

	# autostart/stop?
	[ ${jid} -eq 0 ] && log_err 1 "${N1_COLOR}${CBSD_APP}jail not running: ${N2_COLOR}${jname}${N0_COLOR}"

	[ ! -d ${etcupdate_jail_root} ] && ${MKDIR_CMD} -p ${etcupdate_jail_root}
	# we need RW place for log? redefine log path and use nullfs in RO?
	[ ! -d ${etcupdate_jail_root}/current ] && ${CP_CMD} -a ${_etcupdate_from_dir}/current ${etcupdate_jail_root}

	for i in ${etcupdate_exclude_path}; do
		_exclude_args="${_exclude_args} -I ${i}"
	done

	${ETCUPDATE_CMD} -d ${etcupdate_jail_root} -t ${_etcupdate_to_dir}/etcupdate.tgz -D ${path} ${_exclude_args} ${extra_etcupdate_flags}
	_ret=$?

	if [ ${_ret} -ne 0 ]; then
		if [ -d ${etcupdate_jail_root}/conflicts ]; then
			_files=$( ${FIND_CMD} ${etcupdate_jail_root}/conflicts -type f | while read a; do
				p2=${a##*${etcupdate_jail_root}/conflicts}
				[ -z "${p2}" ] && continue
				echo "  * ${p2}"
			done )
			${ECHO} "${W1_COLOR}${CBSD_APP} warning${N1_COLOR}: confict files:${N0_COLOR}"
			echo "${_files}"
			${ECHO} "${N1_COLOR}${CBSD_APP} please run: ${N2_COLOR}cbsd etcupdate mode=resolve jname=${jname}${N1_COLOR} to run etcupdate resolve${N0_COLOR}"
			${ECHO} "${N1_COLOR}${CBSD_APP}: use ${N2_COLOR}EDITOR=${N1_COLOR} environment variable to use favorite editor${N0_COLOR}"
		fi
	fi

	return ${_ret}
}

etcupdate_resolve()
{
	local _ret
	[ -z "${jname}" ] && log_err 1 "${N1_COLOR}Please set jset: ${N2_COLOR}jname${N0_COLOR}"
	. ${jrcconf}
	[ $? -eq 1 ] && log_err 1 "${N1_COLOR}${CBSD_APP}: no such jail: ${N2_COLOR}${jname}${N0_COLOR}"

	_etcupdate_from_dir="${srcdir}/src_${ver}/etcupdate"
	if [ ! -d ${_etcupdate_from_dir}/current ]; then
		err 1 "${N1_COLOR}no such workdir, please run: ${N2_COLOR}cbsd etcupdate mode=update jname=${jname} from=${N0_COLOR}"
	fi
	${ECHO} "${N1_COLOR}${CBSD_APP} source hier: ${N2_COLOR}${_etcupdate_from_dir}/current${N0_COLOR}"

	${ETCUPDATE_CMD} resolve -d ${etcupdate_jail_root} -D ${path}
	_ret=$?
	return ${_ret}
}

odefault_obtain_etcupdate_method=
oforce=

[ -n "${default_obtain_etcupdate_method}" ] && odefault_obtain_etcupdate_method="${default_obtain_etcupdate_method}"
[ -n "${force}" ] && oforce="${force}"

readconf etcupdate.conf

[ -n "${odefault_obtain_etcupdate_method}" ] && default_obtain_etcupdate_method="${odefault_obtain_etcupdate_method}"
[ -n "${oforce}" ] && force="${oforce}"

# set defaults
[ -z "${force}" ] && force=0

etcupdate_ver="${ver}"

if [ -n "${jname}" ]; then
	. ${jrcconf}
	[ "${emulator}" = "bhyve" ] && err 1 "${N1_COLOR}${CBSD_APP}: not for bhyve mode${N0_COLOR}"
	etcupdate_jail_root="${jailsysdir}/${jname}/etcupdate"
fi

jail_ver="${ver}"

case "${mode}" in
	extract)
		if [ -n "${jname}" ]; then
			etcupdate_jail_extract
			ret=$?
		else
			etcupdate_base_extract
			ret=$?
		fi
		;;
	build)
		etcupdate_base_build
		ret=$?
		;;
	update)
		etcupdate_update
		ret=$?

		if [ ${ret} -eq 0 ]; then
			${ECHO} "${N1_COLOR}${CBSD_APP}: update successfull, bootstrap for: ${N1_COLOR}${ver}${N0_COLOR}"
			etcupdate jname=${jname} mode=extract default_obtain_etcupdate_method=index ver=${to} force=1
		else
			${ECHO} "${N1_COLOR}${CBSD_APP}: update failed${N0_COLOR}"
		fi
		;;
	purge)
		[ -d ${etcupdate_jail_root} ] && ${RM_CMD} -rf ${etcupdate_jail_root}
		;;
	resolve)
		etcupdate_resolve
		ret=$?
		if [ ${ret} -eq 0 ]; then
			${ECHO} "${N1_COLOR}${CBSD_APP}: update successfull, bootstrap for: ${N1_COLOR}${ver}${N0_COLOR}"
			etcupdate jname=${jname} mode=extract default_obtain_etcupdate_method=index ver=${to} force=1
		else
			${ECHO} "${N1_COLOR}${CBSD_APP}: update failed${N0_COLOR}"
		fi
		;;
	*)
		err 1 "${N1_COLOR}${CBSD_APP} error: unknown mode: ${N2_COLOR}${mode}${N0_COLOR}"
		;;
esac

exit ${ret}
