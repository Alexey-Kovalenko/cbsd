if [ ! "$_CBSD_SETTINGS_TUI_SUBR" ]; then
_CBSD_SETTINGS_TUI_SUBR=1
###

#required for . ${dialog} 
TMPFILE="${ftmpdir}/inputbox.$$"

allow_devfs_msg="Allow privileged users inside the jail mount and unmount DEVFS file system"
allow_dying_msg="Allow making changes to a dying Jail"
allow_fdescfs_msg="Jail may mount the fdescfs file system"
allow_fusefs_msg="Allow privileged users inside the jail mount and unmount fuse-based file systems."
allow_kmem_msg="Allow kmem and /dev/io devices for jail. Warning: this is insecure options. Use it only for private purposes/X-jails"
allow_mount_msg="Allow privileged users inside the jail mount and unmount file system"
allow_nullfs_msg="Allow privileged users inside the jail mount and unmount NULLFS file system"
allow_procfs_msg="Allow privileged users inside the jail mount and unmount PROCFS file system"
allow_raw_sockets_msg="The jail root is allowed to create raw sockets"
allow_read_msgbuf_msg="Allow an unprivileged user to read the kernel message buffer"
allow_reserved_ports_msg="Allow the jail root may bind to ports lower than 1024. For FreeBSD 11.1+"
sysvsem_msg="Controls access to SYSV semaphores"
sysvshm_msg="Controls access to shared memory"
sysvmsg_msg="Controls access to SYSV message queues"
allow_tmpfs_msg="Allow privileged users inside the jail mount and unmount TMPFS file system"
allow_unprivileged_proc_debug_msg="Unprivileged processes in the jail may use debugging facilities"
allow_vmm_msg="The jail may access vmm(4). Usefull for jailed bhyve"
allow_zfs_msg="Privileged users inside the jail will be able to mount and unmount the ZFS file system"
applytpl_msg="1,yes - Apply CBSD templates for Jail environment"
arch_msg="Target architecture, i386/amd64 or qemu-users arch"
astart_msg="1,yes - Automatically start Jail when system boot"
basename_msg="Alternative jailbase name"
baserw_msg="1,yes - Jail have personal copy of base system with write access, no NULLFS mount. 0,no - read-only and NULLFS"
childrenmax_msg="Enable hierarchical jails and set limit max children"
cpuset_msg="Associate group of CPUs to jail. 0 - for all cores, See man 1 cpuset for valid value"
data_msg="Data directory for Jail"
depend_msg="Specify a Jail or jails that this jail depends on"
devfs_ruleset_msg="DEVFS ruleset number for Jail devfs"
enforce_statfs_msg="This determines what information processes in a jail are able to get about mount points"
exec_consolelog_msg="Jail consolelog file for stdout/stderr output. Possible values: path_to_file, 0 - for disable log to file, 1 - for automatic $logdir/jname.log"
exec_fib_msg="The FIB routing table to set when running commands inside the prison"
exec_timeout_msg="The maximum amount of time to wait for a command to complete"
floatresolv_msg="1,yes - Floating /etc/resolv.conf content"
hidden_msg="Invisible environment flag. 1 - hide environment for frontend"
host_hostname_msg="Jail Fully Qualified Domain Name"
interface_msg="Auto create and auto remove IP on selected NICs. 0 for disable, auto - for auto detect"
ip4_addr_msg="Jail IPv4 and/or IPv6 address. Current CBSD IPv4 pool: ${nodeippool}\n\
 Use IP/PREFIX form, comma-separated for aliases.\n\
 '0' to disable IP creating by CBSD (useful for vnet jails)\n\
 'DHCP' for determine free IPv4 automatically\n\
 'nic1#ip_addr,nic2#ip_addr' for multiple NIC form\n"
jdomain_msg="Specify CBSD node group name for jail"
jname_msg="Jail name. Name must begin with a letter / a-z /  and not have any special symbols: -,.=%"
kernelmount_msg="1,yes - Jail have mounted /boot/kernel tree in read-only. Usefull for DTRACE stuff in Jail"
mdsize_msg="Enter size for the images"
mkhostsfile_msg="Automatically set IP/NAME in /etc/hosts when jail started"
mount_devfs_msg="Mount DEVFS filesystem in the jail"
mount_fdescfs_msg="Mount a FDESCFS filesystem on the chrooted /dev/fd directory"
mount_kernel_msg="1,yes - Jail have mounted /boot/kernel tree in read-only. Usefull for DTRACE stuff in Jail"
mount_obj_msg="1,yes - Jail have mounted /usr/obj tree in read-only"
mount_ports_msg="1,yes - Jail have /usr/ports /usr/ports tree in read-only"
mount_src_msg="1,yes - Jail have shared /usr/src tree in read-only"
path_msg="Mount point for Jail"
persist_msg="Allows a jail to exist without any processes."
protected_msg="Prevent modification or deletion of a environment. 1 - protect/lock"
runasap_msg="Start jail ASAP upon creation"
stop_timeout_msg="The maximum amount of time to wait for a jailed processes to exit after sending them a SIGTERM signal"
ver_msg="Jail base source version"
vnet_msg="1.yes - Enable VIMAGE/VNet feature"
zfs_snapsrc_msg="Use this ZFS snapshot as source for jail data, e.g zmirror/jails/jail1@init"

GET_ALLOW_READ_MSGBUF_MSG="Select READ_MSGBUF behaviour"
GET_ALLOW_VMM_MSG="Select allow.vmm behaviour"
GET_CD_BOOT_FIRMWARE_MSG="Choose CD boot firmware"
GET_CONSOLE_MSG="Choose default console"
GET_CPUS_MSG="Number of CPUs: 1, max: 16"
GET_EFI_MSG="Choose UEFI firmware"
GET_GUESTFS_MSG="Choose FS for boot image"
GET_GW4_MSG="Enter default gateway inside VMs or jail"
GET_HOSTBRIDGE_MSG="Hostbridge for VMs, eg: hostbridge or amd_hostbridge"
GET_IMGSIZE_MSG="Allocate X size of image free space: 100m, 1g"
GET_IMGTYPE_MSG="Choose image type"
GET_ISOPATH_MSG="Path to ISO image in srcdir/iso, eg: release.iso. 0 - for default img_iso"
GET_JAILPROFILE_MSG="Profile for jcreate"
GET_NODENAME_MSG="Change nodename. Warning: this operation will recreate the ssh keys in $workdir/.ssh dir"
GET_RAM_MSG="RAM in MB, eg: 512, 1024M, 2g"
GET_SWAPSIZE_MSG="Configure swap partitional in X size (usual RAMx2), 0 - for disable, e.g: 4g"
GET_VM_CPU_TOPOLOGY_MSG="Select CPU topology profile name"
GET_VM_ISOPATH_MSG="Select available/registered ISO"
GET_VM_PACKAGE_MSG="Choose package name"
GET_VM_VNC_PORT_MSG="VNC port. 0 - for auto, 1 - disable"
GET_VMPROFILE_MSG="Select profile for VMs"

# show [] * for empty $1 values
# for Option list from -tui
curval()
{
	local T
	[ -z "${1}" ] && return 0

	eval T="\$$1"
	if [ -n "${T}" ]; then
		printf "${T}"
	else
		printf " "
	fi
	return 0
}

# Increment index for menu counter
# required cbsd as shell for is_number
inc_menu_index()
{
	local T
	[ -z "${1}" ] && return 0

	eval T="\$$1"

	if ! is_number ${T}; then
		T=$(( T + 1 ))
	else
		T=$( echo ${T} | /usr/bin/tr '[ABCDEFGHIJKLMNOPQRSTUVWXYZ]' '[BCDEFGHIJKLMNOPQRSTUVWXYZA]' )
	fi
	eval "${1}=${T}"
	return 0
}

# form for $pkglist
get_construct_pkglist()
{
	local _i

	[ -z "${pkglist}" -o "${pkglist}" = "NO" ] && pkglist="${ftmpdir}/tui.$$"

	# load pkg list from profile
	if [ -n "${tpl_pkglist}" ]; then
		if [ -r "${tpl_pkglist}" ]; then
			/bin/cat ${tpl_pkglist} >> ${pkglist}
		else
			for _i in ${tpl_pkglist}; do
				echo ${_i} >> ${pkglist}
			done
		fi
	fi

	pkgbrowser controlmaster="${pkglist}"
	[ ! -s "${pkglist}" ] && pkglist="NO"
}

# form for $srvlist
get_construct_services()
{
	local msg_ok="Got it"

	if [ -z "${ver}" ]; then
		f_dialog_msgbox "Please select ver for jail version first"
		return 0
	fi

	if [ -z "${arch}" ]; then
		f_dialog_msgbox "Please select arch for jail architecture first"
		return 0
	fi

	init_basedir

	if [ -z "${BASE_DIR}" ]; then
		f_dialog_msgbox "BASE_DIR empty"
		return 0
	fi

	if [ ! -x ${BASE_DIR}/bin/sh ]; then
		f_dialog_msgbox "No such basejail: ${BASE_DIR}\n Please fetch this first"
		return 0
	fi

	srvlist="${ftmpdir}/srv.$$"
	srvbrowser controlmaster="${srvlist}" baseonly=1 path=${BASE_DIR}
	[ ! -s "${srvlist}" ] && srvlist="NO"
}

# form for $srvlist
get_construct_add_user()
{
	adduser="${ftmpdir}/adduser.$$"
	adduser-tui controlmaster="${adduser}"
	[ ! -s "${adduser}" ] && adduser=
}

# form for $jname
# if $1 = "nosearch" than skip for searching/testing of available jname
get_construct_jname()
{
	local _ok _message _input _retval _oldjname

	_oldjname="${jname}"

	f_dialog_title " jname "

	if [ "$1" = "nosearch" ]; then
			freejname=${jname}
	else
		if [ -n "${jname}" ]; then
			freejname="${jname}"
		else
			freejname=$( freejname default_jailname=${default_jailname} )
		fi
	fi
	_ok=0

	while [ ${_ok} -ne 1 ]; do
		f_dialog_input _input "${jname_msg}" "${freejname}" \
			"${_message}" || return $?

		validate_jname ${_input}
		case $? in
			1)
				jstatus jname="${_input}" >/dev/null 2>&1
				if [ $? -ne 0 ]; then
					_message="ERROR: Jail ${_input} already exist"
				else
					_ok=1
				fi
				;;
			*)
				_message="ERROR: Bad name. Choose other one"
				;;
		esac
	done

	[ -n "${_input}" ] && jname="${_input}"
	# reload some dynamic variables depended from jname
	[ -z "${jname}" ] && return 0
	if [ "${_oldjname}" != "${jname}" ]; then
		#merge_apply_profiles ${etcdir}/defaults/${zero_profile} ${global_profile_file}
		host_hostname="${jname}.${default_domain}"
		path="${jaildir}/${jname}"
		data="${jaildatadir}/${jname}-${jaildatapref}"
		mount_fstab="${jailfstabdir}/${jailfstabpref}${jname}"
		rcconf="${jailrcconfdir}/rc.conf_${jname}"
	fi
}

# form for $host_hostname
get_construct_host_hostname()
{
	local _input _defdomain

	f_dialog_title " host_hostname "

	if [ -n "${host_hostname}" ]; then
		_defdomain="${host_hostname}"
	else
		if [ -n "${default_domain}" ]; then
			if [ -z "${jname}" ]; then
				_defdomain="${jname}.${default_domain}"
			else
				_defdomain="jail1.${default_domain}"
			fi
		else
			_defdomain="my.domain"
		fi
	fi

	f_dialog_input _input "${host_hostname_msg}" "${_defdomain}" \
			"${_message}" || return $?

	[ -n "${_input}" ] && host_hostname="${_input}"
}

get_construct_ip4_addr()
{
	local _ok=0 _input _retval _i _j _existing_ipjail _existing_ip _myip
	local msg_yes msg_no IFS _jname _ips _mod=0 _tmp_input=

	. ${distdir}/vnet.subr	# is_nic_exist

	f_dialog_title " ip_addr "

	while [ ${_ok} -ne 1 ]; do
		if [ -z "${ip4_addr}" ]; then
			ip4_addr=$( dhcpd 2>/dev/null )
			if [ $? -eq 2 ]; then
				ip4_addr="DHCP"
				local msg_ok="It's a pity"
				f_dialog_msgbox "No free IP address for DHCP in nodeippool"
				return 0
			fi
		fi
		f_dialog_input _input "${ip4_addr_msg}" "${ip4_addr}" "IP4 or IP6 Address"
		_retval=$?

		[ ${_retval} -ne 0 ] && return 0

		#check ip in two phases:
		# 1) via sqlite database for other's jails ips
		# 2) for ip in LAN

		if [ -z "${_input}" -a "${_input}" = "0" -a "{_input}" = "DHCP" ]; then
			ip4_addr="${_input}"
			return 0
		fi

		# Yes, we wrote in the example that the valid separator between NIC and address
		# is '#' and not '|' as experienced jail.conf users can get used to.
		# But we will still try to convert the input with '|' to correct form
		strpos --str="${_input}" --search="|"
		_pos=$?
		 [ ${_pos} -ne 0 ] && _input=$( echo ${_input} | /usr/bin/tr '|' '#' )

		msg_yes="Ok"
		msg_no="Not Ok"

		_existing_ipjail=""
		_existing_ip=""
		_myip=""

		IFS=","
		for _i in ${_input}; do

			if [ "${_i}" = "DHCP" ]; then
				_i=$( dhcpd 2>/dev/null )
				if [ $? -eq 2 ]; then
					local msg_ok="It's a pity"
					f_dialog_msgbox "No free IP address for DHCP in nodeippool"
					return 0
				fi
				_mod=1		# modify real input by _tmp_input string ( with DHCP-obtained IP address )
			fi

			if [ -z "${_tmp_input}" ]; then
				_tmp_input="${_i}"
			else
				_tmp_input="${_tmp_input},${_i}"
			fi

			ipwmask ${_i}
			[ -z "${IWM}" -o "${_i}" = "0" ] && continue

			iptype ${IWM}
			if [ $? -ne 0 ]; then
				if [ -n "${V_INTERFACE}" -a -n "${V_IP}" ]; then
					if ! is_nic_exist -n ${V_INTERFACE}; then
						local msg_ok="I was wrong"
						f_dialog_msgbox "Interface ${V_INTERFACE} not exist!"
						return 0
					fi
					_myip="${_myip} ${V_IP}"
				else
					_myip="${_myip} ${IWM}"
				fi
			fi
		done

		[ ${_mod} -eq 1 ] && _input="${_tmp_input}"

		# check for other jail
		IFS="|"
		_i=0
		eval $( cbsdsql local SELECT jname,ip4_addr FROM jails WHERE ip4_addr!="0" 2>/dev/null |while read _jname _ips; do
			echo jname${_i}=\"$_jname\"
			echo ips${_i}=\"${_ips}\"
			_i=$(( _i + 1 ))
		done )
		unset IFS

		_ok=1

		for _i in $( /usr/bin/seq 0 255 ); do
			unset _existing_ipjail _existing_ip
			eval _jname="\$jname$_i"
			[ -z "${_jname}" ] && break
			# skip for myself
			[ "${_jname}" = "${jname}" ] && continue
			eval _existing_ipjail="\$ips$_i"
			[ -z "${_existing_ipjail}" ] && break

			_existing_ipjail=$( echo ${_existing_ipjail} | /usr/bin/tr "," " " )

			for _x in ${_existing_ipjail}; do
				[ "${_x}" = "DHCP" ] && continue
				ipwmask ${_x}
				[ -z "${IWM}" ] && continue
				iptype ${IWM}
				[ $? -eq 1 ] && _existing_ip="${_existing_ip} ${IWM}"
			done

			for _x in ${_existing_ip}; do
				for _j in ${_myip}; do
					[ "${_x}" = "${_j}" ] && _ok=0 && break
				done
				[ ${_ok} -eq 0 ] && break
			done

			if [ ${_ok} -eq 0 ]; then
				f_dialog_noyes "${_j} already assigned to jail: ${_jname}.\nIf you believe that it's ok, choose 'ok' to continue or 'not ok' for another IP address" "WARNING"
				if [ $? -eq 1 ]; then
					_ok=0
					break
				fi
				_ok=2
				break
			fi
		done # check for local jail end

		[ ${_ok} -eq 0 ] && continue # if not ok from previous stage - repeat
		[ ${_ok} -eq 2 ] && _ok=1 && continue

		_ok=1

		local _ipexist=

		# check for ip existance in LAN
		for _i in ${_myip}; do
			IFS=" "
			f_dialog_info "Probing for ${_i} availability. Please wait..."
			unset IFS
			checkip ip=${_i} check=1 2>/dev/null
			if [ $? -eq 2 ]; then
				_ok=0
				_ipexist="${_ipexist} ${_i}"
			fi
		done

		if [ ${_ok} -eq 0 ]; then
			f_dialog_noyes "Seems like ${_ipexist} address already used on several devices on the LAN\nYou can found MAC address by \"arp -an\" command.\n If you believe that it's ok, choose 'ok' to continue or 'not ok' for another IP address" "WARNING"
			[ $? -eq 0 ] && _ok=1
		fi
	done

	ip4_addr="${_input}"
	return 0
}

# form for $interface
# -b 1 - add "bridge" device
# -c choose_default item - defaultitem set to this value
# -s "skip this network list"
# -d 1  - add "disable" choice
# -m 1  - add "manual" choice
# -v 1  - add "vale" device
get_construct_interface()
{
	local _input _def_iface _mynic _mydesc _mystatus
	local defaultitem _skipnics="" _disable=0 _choose
	local _manual=0 _vale=0 _bridge=0

	local title=" interface "
	local prompt="${interface_msg}"
	hline=

	local menu_list="
		'EXIT'	'EXIT'	'Exit'
	" # END-QUOTE

	while getopts "b:c:s:d:m:v:" opt; do
		case "$opt" in
			b) _bridge="${OPTARG}" ;;
			c) _choose="${OPTARG}" ;;
			s) _skipnics="${OPTARG}" ;;
			d) _disable="${OPTARG}" ;;
			m) _manual="${OPTARG}" ;;
			o) _optional="${OPTARG}" ;;
			v) _vale="${OPTARG}" ;;
		esac
		shift $(($OPTIND - 1))
	done

	menu_list="${menu_list} 'auto'		'auto'		'Recommended: determine nic for jail IP via route table.'"
	if [ "${_manual}" = "1" ]; then
		menu_list="${menu_list} 'manual'	'manual'	'Enter interface by hand.'"
	fi

	if [ ${_disable} -eq 1 ]; then
		menu_list="${menu_list} 'disable'	'disable'	'Do not create/remove IP automatically: IP of jail must be already initialized or for vnet mode'"
	fi
	menu_list="${menu_list} '-'	'-'	''"

	local OLDIFS="${IFS}"
	local IFS=":"

	local _num=1

	eval $( ${miscdir}/nics-list -da -s "${_skipnics}" |while read _nicname _nicdesc _nicstatus; do
		echo "nic${_num}_name=\"${_nicname}\""
		echo "nic${_num}_desc=\"${_nicdesc}\""
		echo "nic${_num}_status=\"${_nicstatus}\""
		_num=$(( _num + 1 ))
		echo "_num=\"${_num}\""
	done )

	if [ "${_vale}" = "1" ]; then
		eval $( cbsdsql local SELECT name FROM vale | while read name; do
			echo "nic${_num}_name=\"vale_${name}\""
			echo "nic${_num}_desc=\"VALE SWITCH: ${name}\""
			echo "nic${_num}_status=\"UP\""
			_num=$(( _num + 1 ))
			echo "_num=\"${_num}\""
		done )
#		eval "nic${_num}_name='vale'"
#		eval "nic${_num}_desc='very fast Virtual Local Ethernet using the netmap API'"
#		eval "nic${_num}_status='UP'"
	fi

	if [ "${_bridge}" = "1" ]; then
		#menu_list="${menu_list} '-'	'Existing bridges'	'Use existing bridges'"
		eval $( ${miscdir}/nics-list -o "bridge" | while read _nicname; do
			echo "nic${_num}_name=\"${_nicname}\""
			echo "nic${_num}_status=\"initialized\""
			_num=$(( _num + 1 ))
			echo "_num=\"${_num}\""
		done )
	fi

	IFS="${OLDIFS}"

	if [ -n "${interface}" ]; then
		case "${interface}" in
			"0")
				defaultitem="disable"
				;;
			*)
				defaultitem="${interface}"
				;;
		esac
	else
		if [ -n "${_choose}" ]; then
			defaultitem="${_choose}"
		elif [ -n "${interface}" ]; then
			defaultitem="${interface}"
		else
			interface="auto"
			defaultitem="auto"
		fi
	fi

	[ -n "${_choose}" ] && defaultitem="${_choose}"

	for _num in $( /usr/bin/seq 1 9999 ); do
		unset _mynic _mydesc _mystatus
		eval _mynic="\$nic${_num}_name"
		[ -z "${_mynic}" ] && break
		eval _mydesc="\$nic${_num}_desc"
		eval _mystatus="\$nic${_num}_status"
		case "${_mynic%%[0-9]*}" in
			tun|bridge|epair|tap|vlan)
				_mydesc="Pseudo interface"
				;;
			lo)
				_mydesc="Loopback interface"
				;;
		esac
		[ -z "${_mydesc}" ] && _mydesc="Not available"
		menu_list="${menu_list} '${_mynic}'	'${_mynic} (${_mystatus} )'	'Description: ${_mydesc}'"
	done

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			case "${mtag}" in
				"-")
					continue
					;;
				EXIT)
					return 1
					;;
				disable)
					interface="0"
					;;
				manual)
					defaultitem="auto"
					title=" interface "
					prompt="Enter interface"
					cbsd_inputbox_simple && interface="${mtag}"
					;;
				*)
					[ -n "${mtag}" ] && interface="${mtag}"
					;;
			esac
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $ver
get_construct_ver()
{
	title=" ver "
	prompt="${ver_msg}"
	defaultitem="${ver}"

	cbsd_inputbox_simple && ver="${mtag}"
}

# form for $bhyve_flags
get_construct_bhyve_flags()
{
	title=" additioal bhyve_flags "
	prompt="enter additional bhyve(8) args"
	defaultitem="${bhyve_flags}"

	cbsd_inputbox_simple && bhyve_flags="${mtag}"
}

# form for $basename
get_construct_basename()
{
	title=" basename "
	prompt="${basename_msg}"
	defaultitem="${basename}"

	cbsd_inputbox_simple && basename="${mtag}"
}

# form for $exec_stop
get_construct_exec_stop()
{
	title=" exec_stop "
	prompt=" Redefine for exec_stop "
	defaultitem="${exec_stop}"

	cbsd_inputbox_simple && exec_stop="${mtag}"
}

# form for $exec_start
get_construct_exec_start()
{
	title=" exec_start "
	prompt=" Redefine for exec_start "
	defaultitem="${exec_start}"

	cbsd_inputbox_simple && exec_start="${mtag}"
}

# form for $childrenmax
get_construct_childrenmax()
{
	title=" childrenmax "
	prompt="${childrenmax_msg}"
	defaultitem="${childrenmax}"

	cbsd_inputbox_simple && childrenmax="${mtag}"
}

# form for $enforce_statfs
get_construct_enforce_statfs()
{
	title=" enforce_statfs "
	prompt="${enforce_statfs_msg}"
	defaultitem="${enforce_statfs}"

	cbsd_inputbox_simple && enforce_statfs="${mtag}"
}


# form for $zfs_snapsrc
get_construct_zfs_snapsrc()
{
	title=" zfs_snapsrc "
	prompt="${zfs_snapsrc_msg}"
	defaultitem="${zfs_snapsrc}"

	if cbsd_inputbox_simple; then
		if [ -n "${mtag}" ]; then
			zfs_snapsrc="${mtag}"
		else
			unset zfs_snapsrc
		fi
	fi
}


# form for select password
# if $1 - can_empty than allow empty passowrd
get_password()
{
	local prompt1="Enter New Password"
	local prompt2="Re-enter Password"
	local hline="Use alpha-numeric, punctuation, TAB or ENTER"

	if [ "${1}" = "can_empty" ]; then
		local can_empty=1
	else
		local can_empty=0
	fi

	f_dialog_title " Select Password "

	local height1 width1
	f_dialog_inputbox_size height1 width1 \
		"$DIALOG_TITLE"     \
		"$DIALOG_BACKTITLE" \
		"$prompt1"          \
		""                  \
		"$hline"

	local height2 width2
	f_dialog_inputbox_size height2 width2 \
		"$DIALOG_TITLE"     \
		"$DIALOG_BACKTITLE" \
		"$prompt2"          \
		""                  \
		"$hline"

	#
	# Loop until the user provides taint-free/valid input
	#
	local _password1 _password2
	while :; do
		_password1=$( $DIALOG \
			--title "$DIALOG_TITLE"         \
			--backtitle "$DIALOG_BACKTITLE" \
			--hline "$hline"                \
			--ok-label "$msg_ok"            \
			--cancel-label "$msg_cancel"    \
			--insecure                      \
			--passwordbox "$prompt1"        \
			$height1 $width1                \
			2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
		) || return $?
		# Return if user either pressed ESC or chose Cancel/No
		debug= f_dialog_line_sanitize _password1

		_password2=$( $DIALOG \
				--title "$DIALOG_TITLE"         \
				--backtitle "$DIALOG_BACKTITLE" \
				--hline "$hline"                \
				--ok-label "$msg_ok"            \
				--cancel-label "$msg_cancel"    \
				--insecure                      \
				--passwordbox "$prompt2"        \
				$height2 $width2                \
				2>&1 >&$DIALOG_TERMINAL_PASSTHRU_FD
			) || return $?
		# Return if user either pressed ESC or chose Cancel/No
		debug= f_dialog_line_sanitize _password2

		if [ ${can_empty} -eq 0 ]; then
			# Check for NULL entry
			if ! [ "$_password1" -o "$_password2" ]; then
				f_show_msg "Password is empty"
				continue
			fi
			mtag=''
		fi

		# Check for password mismatch
		if [ "$_password1" != "$_password2" ]; then
			f_show_msg "Password do not match"
			continue
		fi

		mtag="$_password1"
		break
	done

	return $DIALOG_OK
}


# form for $user_pw_root
get_construct_user_pw_root()
{
	if get_password; then
		user_pw_root_crypt=$( ${miscdir}/pwcrypt ${mtag} )
		if [ $? -eq 0 ]; then
			unset user_pw_root
		else
			user_pw_root="${mtag}"
			unset user_pw_root_crypt
		fi
	fi
}

# form for $vnc_password
get_construct_vnc_password()
{
	if get_password can_empty; then
		vnc_password="${mtag}"
	else
		unset vnc_password
	fi

	[ -z "${vnc_password}" ] && vnc_password="0"
}

# form for $spice_password
get_construct_spice_password()
{
	if get_password can_empty; then
		spice_password="${mtag}"
	else
		unset spice_password
	fi

	[ -z "${spice_password}" ] && spice_password="0"
}

# form for $bhyve_vnc_vgaconf
get_construct_bhyve_vnc_vgaconf_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VGACONF setting"
	local defaultitem="${bhyve_vnc_vgaconf}"

	local menu_list="
		'io'	'io'	'I/O port queries'
		'on'	'on'	'for legacy VGA I/O and memory regions'
		'off'	'off'	'VGA adapter is present if they detect the I/O ports'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_vgaconf="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}

}

# form for $debug_engine
get_construct_debug_engine()
{
	local _input _res

	local title="Debug engine"
	local defaultitem="${debug_engine}"

	local menu_list="
		'gdb'	'gdb'	'GNU debugger'
		'lldb'	'lldb'	'LLVM debuger'
		'none'	'none'	'No debuger'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && debug_engine="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $path
get_construct_path()
{
	title=" path "
	prompt="${path_msg}"
	defaultitem="${path}"

	cbsd_inputbox_simple && path="${mtag}"
}

# form for $data
get_construct_data()
{
	title=" data "
	prompt="${data_msg}"
	defaultitem="${data}"

	cbsd_inputbox_simple && data="${mtag}"
}


# form for $devfs_ruleset
get_construct_devfs_ruleset()
{
	title=" devfs_ruleset "
	prompt="${devfs_ruleset_msg}"
	defaultitem="${devfs_ruleset}"

	cbsd_inputbox_simple && devfs_ruleset="${mtag}"
}

# $1 - 1,0 - default values
get_construct_yesno()
{
	local _default=1
	msg_yes="no"
	msg_no="yes"

	[ -n "${1}" ] && _default="${1}"

	if [ ${_default} -eq 0 ]; then
		f_dialog_yesno "${msg}" "${hline}"
	else
		f_dialog_noyes "${msg}" "${hline}"
	fi

	return $?
}

get_construct_mdsize()
{
	title=" mdsize "
	prompt="${mdsize_msg}"
	defaultitem="${mdsize}"

	cbsd_inputbox_simple && mdsize="${mtag}"
}

get_construct_imgsize()
{
	local _input

	f_dialog_title " imgsize "

	f_dialog_input _input "${GET_IMGSIZE_MSG}:" "${imgsize}" \
			"${_message}" || return $?

	imgsize="${_input}"
}

get_construct_swapsize()
{
	local _input

	f_dialog_title " swapsize "

	f_dialog_input _input "${GET_SWAPSIZE_MSG}:" "${swapsize}" \
			"${_message}" || return $?

	swapsize="${_input}"
}


# form for $exec_timeout
get_construct_exec_timeout()
{
	local _input

	f_dialog_title " exec_timeout "

	f_dialog_input _input "${exec_timeout_msg}" "${exec_timeout}" \
			"${_message}" || return $?

	exec_timeout="${_input}"
}

# form for $exec_fib
get_construct_exec_fib()
{
	local _input

	f_dialog_title " exec_fib "

	f_dialog_input _input "${exec_fib_msg}" "${exec_fib}" \
			"${_message}" || return $?

	exec_fib="${_input}"
}

# form for $exec_consolelog
get_construct_exec_consolelog()
{
	local _input

	f_dialog_title " exec_consolelog "

	f_dialog_input _input "${exec_consolelog_msg}" "${exec_consolelog}" \
		"${_message}" || return $?

	exec_consolelog="${_input}"
}

# form for $stop_timeout
get_construct_stop_timeout()
{
	local _input

	f_dialog_title " stop_timeout "

	f_dialog_input _input "${stop_timeout_msg}" "${stop_timeout}" \
		"${_message}" || return $?

	stop_timeout="${_input}"
}

# form for $depend
get_jail_depend()
{
	local _input

	f_dialog_title " depend "

	f_dialog_input _input "${depend_msg}" \
		"${_message}" || return $?

	depend="${_input}"
}

# form for $cpuset
get_construct_cpuset()
{
	local _input

	f_dialog_title " cpuset "

	f_dialog_input _input "${cpuset_msg}" "${cpuset}" \
			"${_message}" || return $?

	cpuset="${_input}"
}

# form for $cpus
get_construct_vm_cpus()
{
	local _input _message=" current hoster logical CPUs: ${ncpu} "
	local _ret=1

	f_dialog_title " vCpus "

	while [ ${_ret} -ne 0 ]; do

		f_dialog_input _input "${GET_CPUS_MSG}" "${vm_cpus}" \
			"${_message}" || return $?

		if is_number ${_input}; then
			f_show_msg "Only number is valid input for cpu"
			continue
		fi

		if [ ${_input} -gt ${ncpu} -a ${_input} -lt 16 ]; then
			if ! getyesno "Warning! Current node cpu: ${ncpu}. Overcommitting vCPUs can hurt perfomance.\nContinue anyway?"; then
				continue
			fi
		elif [ ${_input} -lt 1 -o ${_input} -gt 16 ]; then
			f_show_msg "Valid number of guest CPUs within 1 - 16 range"
			continue
		fi
		_ret=0
	done
	vm_cpus="${_input}"
}


# form for $vm_vnc_port
get_construct_vm_vnc_port()
{
	local _input

	f_dialog_title " vnc port "

	f_dialog_input _input "${GET_VM_VNC_PORT_MSG}" "${vm_vnc_port}" \
			"${_message}" || return $?

	vm_vnc_port="${_input}"
}

# form for $ram
get_construct_vm_ram()
{
	local _input _tmp

	f_dialog_title " ram "

	f_dialog_input _input "${GET_RAM_MSG}" "${vm_ram}" \
			"${_message}" || return $?

	# test for human
	if ! is_number "${_input}"; then
		# is number. assume user's input value in MB, so convert to bytes
		_input=$(( _input * 1024 * 1024 ))
		if conv2human "${_input}"; then
			_tmp="${convval}"
		else
			_tmp=$(( _input * 1024 * 1024 ))
			if conv2human "${VAL}"; then
				_tmp="${convval}"
			fi
		fi
	else
		_tmp="${_input}"
	fi

	vm_ram="${_tmp}"
}

# form for $vm_iso_path
get_construct_isopath()
{
	local _input

	f_dialog_title " isopath "

	f_dialog_input _input "${GET_ISOPATH_MSG}" "${vm_iso_path}" \
			"${_message}" || return $?

	vm_iso_path="${_input}"
}

# form for $arch
get_construct_arch()
{
	local _input _res

	local qemu_mips64=$( /usr/bin/which qemu-mips64-static 2>/dev/null )
	local qemu_arm=$( /usr/bin/which qemu-arm-static 2>/dev/null )
	local qemu_aarch64=$( /usr/bin/which qemu-aarch64-static 2>/dev/null )

	local amd64_menu=
	local i386_menu=
	local amd64_desc=
	local i386_desc=

	local arm_menu=
	local mips_menu=
	local arm_desc=
	local mips_desc=

	local qemu_mips64_desc=
	local qemu_arm_desc=
	local qemu_aarch64_desc=

	local qemu_mips64_enable=
	local qemu_arm_enable=
	local qemu_aarch64_enable=

	local qemu_mips64_menu="MIPS64"
	local qemu_arm_menu="ARMv6"
	local qemu_aarch64_menu="ARMv8"

	# test for qemu_mips64
	if [ -n "${qemu_mips64}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_mips64} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_mips64_enable=1
			qemu_mips64_desc="MIPS64 via ${qemu_mips64}"
		else
			qemu_mips64_enable=0
			qemu_mips64_desc="${qemu_mips64} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_mips64_enable=0
		qemu_mips64_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	# test for qemu_arm
	if [ -n "${qemu_arm}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_arm} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_arm_enable=1
			qemu_arm_desc="ARM via ${qemu_arm}"
		else
			qemu_arm_enable=0
			qemu_arm_desc="${qemu_arm} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_arm_enable=0
		qemu_arm_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	# test for qemu_aarch64
	if [ -n "${qemu_aarch64}" ]; then
		_res=$( 2>&1 /usr/bin/ldd ${qemu_aarch64} |${GREP_CMD} -q "not a dynamic ELF executable" )
		if [ $? -eq 0 ]; then
			qemu_aarch64_enable=1
			qemu_aarch64_desc="aarch64 aka ARMv8 and arm-64 via ${qemu_arm}"
		else
			qemu_aarch64_enable=0
			qemu_aarch64_desc="${qemu_aarch64} is not static. Please rebuild with STATIC ( emulators/qemu-user-static )"
		fi
	else
		qemu_aarch64_enable=0
		qemu_aarch64_desc="You have no qemu-user: please install qemu-devel with BSD_USER and STATIC ops ( emulators/qemu-user-static )"
	fi

	local defaultitem="${arch}"

	case "${hostarch}" in
		"amd64")
			amd64_menu="*"
			amd64_desc="This is native architecture for this node"
			;;
		"i386")
			i386_menu="*"
			i386_desc="This is native architecture for this node"
			;;
		"arm")
			arm_menu="*"
			arm_desc="This is native architecture for this node"
			;;
		"aarch64")
			aarch64_menu="*"
			aarch64_desc="This is native architecture for this node"
			;;
		"mips")
			mips_menu="*"
			mips_desc="This is native architecture for this node"
			;;
	esac

	case "${arch}" in
		amd64)
			local menu_list="
			'amd64'	'x86-64 ${amd64_menu}'		'64 bit architecture. ${amd64_desc}'
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
		i386)
			local menu_list="
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
		arm)
			local menu_list="
			'arm'	'arm ${arm_menu}'		'ARM architecture. ${arm_desc}'
			" # END-QUOTE
			;;
		aarch64)
			local menu_list="
			'arm'	'aarch64 ${aarch64_menu}'	'ARM architecture. ${aarch64_desc}'
			" # END-QUOTE
			;;
		mips)
			local menu_list="
			'mips'	'mips ${mips_menu}'		'MIPS architecture. ${mips_desc}'
			" # END-QUOTE
			;;
		*)
			local menu_list="
			'amd64'	'x86-64 ${amd64_menu}'		'64 bit architecture. ${amd64_desc}'
			'i386'	'x86 ${i386_menu}'		'32 bit architecture. ${i386_desc}'
			" # END-QUOTE
			;;
	esac

	if [ ${qemu_arm_enable} -eq 1 ]; then
		menu_list="${menu_list} 'arm'	'${qemu_arm_menu}'	'${qemu_arm_desc}'"
	else
		menu_list="${menu_list} ''	'armv6 unsupported'	'${qemu_arm_desc}'"
	fi

	if [ ${qemu_aarch64_enable} -eq 1 ]; then
		menu_list="${menu_list} 'aarch64'	'${qemu_aarch64_menu}'	'${qemu_aarch64_desc}'"
	else
		menu_list="${menu_list} ''		'aarch64 unsupported'	'${qemu_aarch64_desc}'"
	fi

	if [ ${qemu_mips64_enable} -eq 1 ]; then
		menu_list="${menu_list} 'mips'	'${qemu_mips64_menu}'	'${qemu_mips64_desc}'"
	else
		menu_list="${menu_list} ''	'mips unsupported'	'${qemu_mips64_desc}'"
	fi

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				arch="${mtag}"
			else
				arch="${hostarch}"
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_hostbridge
get_construct_vm_hostbridge()
{
	local _input _res

	local title="${GET_HOSTBRIDGE_MSG}"
	local defaultitem="${vm_hostbridge}"

	local menu_list="
		'hostbridge'		'hostbridge'		'Provide a simple host bridge.'
		'amd_hostbridge'	'amd_hostbridge'	'The amd_hostbridge emulation is identical but uses a PCI vendor ID of AMD'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_hostbridge="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vnc_resolution
get_construct_bhyve_vnc_resolution_menu()
{
	local _input _res

	# for default values
	readconf vnc.conf

	local title="VNC Resolution"
	local defaultitem="${bhyve_vnc_resolution}"

	local menu_list="
		'640x480'		'640 x 480'		'640 x 480'
		'800x600'		'800 x 600'		'800 x 600'
		'1024x768'		'1024 x 768'		'1024 x 768'
		'1280x720'		'1280 x 720'		'1280 x 720'
		'1280x1024'		'1280 x 1024'		'1280 x 1024'
		'1600x900'		'1600 x 900'		'1600 x 900'
		'1600x1200'		'1600 x 1200'		'1600 x 1200'
		'1920x1080'		'1920 x 1080'		'1920 x 1080'
		'1920x1200'		'1920 x 1200'		'1920 x 1200'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && bhyve_vnc_resolution="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $sysvsem
get_construct_sysvsem()
{
	local _input _res

	local title="${sysvsem_msg}"
	local defaultitem="${sysvsem}"

	local menu_list="
		'new'			'new'			'New sysvsem: separated isolated segments for jail'
		'inherit'		'inherit'		'Inherit (shared) from parent environment'
		'disable'		'disable'		'Disable sysvsem within jail'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && sysvsem="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $sysvshm
get_construct_sysvshm()
{
	local _input _res

	local title="${sysvshm_msg}"
	local defaultitem="${sysvshm}"

	local menu_list="
		'new'			'new'			'New sysvshm: separated isolated segments for jail'
		'inherit'		'inherit'		'Inherit (shared) from parent environment'
		'disable'		'disable'		'Disable sysvsem within jail'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && sysvshm="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $sysvmsg
get_construct_sysvmsg()
{
	local _input _res

	local title="${sysvmsg_msg}"
	local defaultitem="${sysvmsg}"

	local menu_list="
		'new'			'new'			'New sysvmsg: separated isolated segments for jail'
		'inherit'		'inherit'		'Inherit (shared) from parent environment'
		'disable'		'disable'		'Disable sysvmsg within jail'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && sysvmsg="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# Submenu for bhyve options
get_construct_bhyve_options_menu()
{
	local _input _res item_let=A

	local title="Additional bhyve arguments"
	local defaultitem=
	local menu_choice=
	local _checkbox="bhyve_generate_acpi bhyve_wire_memory bhyve_rts_keeps_utc bhyve_force_msi_irq bhyve_x2apic_mode bhyve_mptable_gen bhyve_ignore_msr_acc"

	f_dialog_default_fetch defaultitem

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} bhyve_generate_acpi'		'[${bhyve_generate_acpi_mark}]'		'Generate ACPI tables.  Required for FreeBSD/amd64 guests'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_wire_memory'			'[${bhyve_wire_memory_mark}]'		'Wire guest memory'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_rts_keeps_utc'		'[${bhyve_rts_keeps_utc_mark}]'		'RTC keeps UTC time'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_force_msi_irq'		'[${bhyve_force_msi_irq_mark}]'		'Force virtio PCI device to use MSI interrupts instead of MSI-X'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_x2apic_mode'			'[${bhyve_x2apic_mode_mark}]'		'The guests local APIC is configured in x2APIC mode'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_mptable_gen'			'[${bhyve_mptable_gen_mark}]'		'Disable MPtable generation'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_ignore_msr_acc'		'[${bhyve_ignore_msr_acc_mark}]'	'Ignore accesses to unimplemented MSRs'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}

# Submenu for jail options in jconstruct-tui
get_construct_jail_options_menu()
{
	local _input _res item_let=A _mark _desc

	local title="Additional jail options"
	local defaultitem=
	local menu_choice=

	# skip for astart, vnet, baserw
	local _checkbox="allow_devfs allow_dying allow_fdescfs allow_fusefs allow_kmem allow_mount allow_nullfs \
allow_procfs allow_raw_sockets allow_read_msgbuf allow_reserved_ports allow_tmpfs allow_unprivileged_proc_debug \
allow_vmm allow_zfs applytpl floatresolv hidden mkhostsfile mount_devfs mount_fdescfs mount_kernel \
mount_obj mount_ports mount_src runasap persist protected"

	f_dialog_default_fetch defaultitem

	local menu_list=""

	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
			_mark="X"
		else
			export ${i}_mark=" "
			_mark=" "
		fi

		eval _desc="\${${i}_msg}"

		menu_list="${menu_list} '${item_let} ${i}'		'[${_mark}]'		'${_desc}'"
		inc_menu_index item_let
	done

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "${menu_choice}"
	f_dialog_default_store "${menu_choice}"

	return $retval
}


# Submenu for vnc options
get_construct_bhyve_vnc_options_menu()
{
	local _input _res item_let=A

	local title="VNC Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="cd_vnc_wait"

	f_dialog_default_fetch defaultitem

	readconf vnc.conf
	[ -z "${bhyve_vnc_resolution}" ] && bhyve_vnc_resolution="${default_vnc_width}x${default_vnc_height}"
	[ -z "${bhyve_vnc_tcp_bind}" ] && bhyve_vnc_tcp_bind="${default_vnc_tcp_bind}"
	[ -z "${bhyve_vnc_vgaconf}" ] && bhyve_vnc_vgaconf="${default_bhyve_vnc_vgaconf}"

	if [ "${vnc_password}" = "0" ]; then
		unset vnc_password
	else
		[ -z "${vnc_password}" ] && vnc_password="${default_vnc_password}"
	fi

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} cd_vnc_wait'		'[${cd_vnc_wait_mark}]'		'When booting from CD - wait connections on VNC before VM run'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_resolution'	'[${bhyve_vnc_resolution}]'	'Default: width - ${default_vnc_width}, height - ${default_vnc_height}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} bhyve_vnc_tcp_bind'	'[${bhyve_vnc_tcp_bind}]'	'Default: ${default_vnc_tcp_bind}'"

	# vgaconf support introduced in FreeBSD 11.1+

	if [ ${freebsdhostversion} -gt 1101000 ]; then
		inc_menu_index item_let
		menu_list="${menu_list} '${item_let} bhyve_vnc_vgaconf'		'[${bhyve_vnc_vgaconf}]'	'Default: ${bhyve_default_vnc_vgaconf}'"
	fi

	# VNC password support introduced in FreeBSD 11.1
	if [ ${freebsdhostversion} -gt 1101000 ]; then
		inc_menu_index item_let
		menu_list="${menu_list} '${item_let} vnc_password'		'[${vnc_password}]'		'Default: see vnc.conf file'"
	fi

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}


# Submenu for cloud init helper
get_construct_cloud_init_menu()
{
	local _input _res item_let=A
	local _pubkey_len

	local prompt="choose cloud-init settings to modify"
	local title="Cloud-init helper options"
	local defaultitem=
	local menu_choice=
	#local _checkbox="cd_vnc_wait"

	f_dialog_default_fetch defaultitem

	# read global default vars
	readconf cloud-init.conf

	[ -z "${ci_user_pw_root_crypt}" ] && ci_user_pw_root_crypt="${default_ci_user_pw_root_crypt}"
	[ -z "${ci_user_add}" ] && ci_user_add="${default_ci_user_add}"

	[ -z "${ci_interface}" ] && ci_interface="${default_ci_interface}"
	[ -z "${ci_ip4_addr}" ] && ci_ip4_addr="${default_ci_ip4_addr}"
	[ -z "${ci_gw4}" ] && ci_gw4="${default_ci_gw4}"
	[ -z "${ci_nameserver_address}" ] && ci_nameserver_address="${default_ci_nameserver_address}"
	[ -z "${ci_nameserver_search}" ] && ci_nameserver_search="${default_ci_nameserver_search}"
	[ -z "${ci_adjust_inteface_helper}" ] && ci_adjust_inteface_helper="${default_ci_adjust_inteface_helper}"
	[ -z "${ci_jname}" ] && ci_jname="${jname}"
	[ -z "${ci_fqdn}" ] && ci_fqdn="${host_hostname}"

	# sets ip4_addr params as well
	ip4_addr="${ci_ip4_addr}"

	# checkbox mark
	#for i in ${_checkbox}; do
	#	eval _mytest=\$$i
	#	if [ "${_mytest}" = "1" ]; then
	#		export ${i}_mark="X"
	#	else
	#		export ${i}_mark=" "
	#	fi
	#done

	local menu_list=""

	menu_list="${menu_list} '${item_let} ci_jname'			'[${ci_jname}]'			'Default: ${jname}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} ci_fqdn'			'[${ci_fqdn}]'			'Default: ${host_hostname}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} ci_user_add'		'[${ci_user_add}]'		'Default: ${default_ci_user_add}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} ci_ip4_addr'		'[${ci_ip4_addr}]'		'Default: ${default_ci_ip4_addr}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} ci_gw4'			'[${ci_gw4}]'			'Default: ${default_ci_gw4}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} ci_nameserver_address'	'[${ci_nameserver_address}]'	'Default: ${default_ci_nameserver_address}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} ci_nameserver_search'	'[${ci_nameserver_search}]'	'Default: ${default_ci_nameserver_search}'"
	inc_menu_index item_let
	menu_list="${menu_list} '-'	'-'	''"

	for i in ${ci_user_add}; do
#			eval _gecos="\$ci_user_gecos_${i}"
#			menu_list="${menu_list} '${item_let} ci_user_gecos_${i}'	'[${_gecos}]'	'user gecos'"
			inc_menu_index item_let
			eval _home="\$ci_user_home_${i}"
			menu_list="${menu_list} '${item_let} ci_user_home_${i}'	'[${_home}]'	'user home'"
			inc_menu_index item_let
			eval _pubkey="\$ci_user_pubkey_${i}"
			_pubkey_len=$( strlen "${_pubkey}" )
			if [ ${_pubkey_len} -gt 30 ]; then
				_pubkey=$( substr --pos=0 --len=30 --str="${_pubkey}" )
				_pubkey="${_pubkey} ..."
			fi
			menu_list="${menu_list} '${item_let} ci_user_pubkey_${i}'	'[${_pubkey}]'	'user pubkey'"
			inc_menu_index item_let
	done

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "${menu_choice}"
	f_dialog_default_store "${menu_choice}"

	ip4_addr="${ci_ip4_addr}"

	return $retval
}

# Submenu for get_construct_cloud_init
get_construct_cloud_init_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"
	local _defaults

	while [ 1 ]; do
		get_construct_cloud_init_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		ci_jname)
			title=" ci_jname "
			prompt=" adjust short host name "
			eval defaultitem="\$${mychoice}"
			cbsd_inputbox_simple && ci_jname="${mtag}"
			;;
		ci_fqdn)
			title=" ci_fqdn "
			prompt=" adjust host FQDN "
			eval defaultitem="\$${mychoice}"
			cbsd_inputbox_simple && ci_fqdn="${mtag}"
			;;
		ci_ip4_addr|ci_user_add|ci_gw4|ci_nameserver_address|ci_nameserver_search)
			title=" ${mychoice} "
			prompt=" adjust ${mychoice} "
			#eval _defaults="\$default_${mychoice}"
			eval defaultitem="\$${mychoice}"
			cbsd_inputbox_simple && eval ${mychoice}="${mtag}"
			;;
		ci_user_home_*|ci_user_gecos_*|ci_user_pubkey_*)
			title=" ${mychoice} "
			prompt=" adjust ${mychoice} "
			#eval _defaults="\$default_${mychoice}"
			eval defaultitem="\$${mychoice}"
			cbsd_inputbox_simple && eval ${mychoice}="\"${mtag}\""
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	[ -n "${ci_jname}" ] && cloud_init_options="[configured]"

	f_dialog_default_store "${old_defaultitem}"
}

# Submenu for vnc options
get_construct_xen_vnc_options_menu()
{
	local _input _res item_let=A

	local title="VNC Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="vnc_enabled"

	f_dialog_default_fetch defaultitem

	readconf vnc.conf
	if [ -z "${vnc_enabled}" ]; then
		vnc_enabled="${vnc_default}"
	fi

	[ -z "${xen_vnc_resolution}" ] && xen_vnc_resolution="${default_vnc_width}x${default_vnc_height}"
	[ -z "${xen_vnc_tcp_bind}" ] && xen_vnc_tcp_bind="${default_vnc_tcp_bind}"
	[ -z "${xen_vnc_vgaconf}" ] && xen_vnc_vgaconf="${default_vnc_vgaconf}"

	if [ "${vnc_password}" = "0" ]; then
		unset vnc_password
	else
		[ -z "${vnc_password}" ] && vnc_password="${default_vnc_password}"
	fi

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} vnc_enabled'		'[${vnc_enabled_mark}]'		'Enable VNC protocol instead of SPICE'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} xen_vnc_tcp_bind'		'[${xen_vnc_tcp_bind}]'		'Default: ${default_vnc_tcp_bind}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} vnc_password'		'[${vnc_password}]'		'Default: see vnc.conf file'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return $retval
}

# Submenu for spice options
get_construct_xen_spice_options_menu()
{
	local _input _res item_let=A

	local title="SPICE Options"
	local defaultitem=
	local menu_choice=
	local _checkbox="spice_enabled"

	f_dialog_default_fetch defaultitem

	readconf spice.conf

	[ -z "${spice_default}" ] && spice_default="${default_spice_default}"

	if [ -z "${spice_enabled}" ]; then
		spice_enabled="${spice_default}"
	fi

	[ -z "${xen_spice_resolution}" ] && xen_spice_resolution="${default_spice_width}x${default_spice_height}"
	[ -z "${xen_spice_tcp_bind}" ] && xen_spice_tcp_bind="${default_spice_tcp_bind}"

	if [ "${spice_password}" = "0" ]; then
		unset spice_password
	else
		[ -z "${spice_password}" ] && spice_password="${default_spice_password}"
	fi

	# checkbox mark
	for i in ${_checkbox}; do
		eval _mytest=\$$i
		if [ "${_mytest}" = "1" ]; then
			export ${i}_mark="X"
		else
			export ${i}_mark=" "
		fi
	done

	local menu_list=""

	menu_list="${menu_list} '${item_let} spice_enabled'		'[${spice_enabled_mark}]'		'Enable SPICE protocol instead of VNC'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} xen_spice_tcp_bind'	'[${xen_spice_tcp_bind}]'	'Default: ${default_spice_tcp_bind}'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} spice_password'		'[${spice_password}]'		'Default: see spice.conf file'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "${menu_choice}"
	f_dialog_default_store "${menu_choice}"

	return ${retval}
}

# Submenu for bhyve options
get_construct_bhyve_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}


# Submenu for jail options
get_construct_jail_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_jail_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}


# Submenu for bhyve options
get_construct_bhyve_vnc_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_bhyve_vnc_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		bhyve_vnc_tcp_bind)
			title=" vnc bind "
			prompt="default via vnc.conf: ${default_vnc_tcp_bind}\nUse 0.0.0.0 for all IPs"
			defaultitem="${bhyve_vnc_tcp_bind}"
			cbsd_inputbox_simple && bhyve_vnc_tcp_bind="${mtag}"
			;;
		bhyve_vnc_resolution)
			get_construct_bhyve_vnc_resolution_menu
			;;
		bhyve_vnc_vgaconf)
			get_construct_bhyve_vnc_vgaconf_menu
			;;
		vnc_password)
			get_construct_vnc_password
			;;
		*)
			invert_checkbox ${mychoice}
			continue
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"

}


get_construct_exit_behavior_menu()
{
	local _input _res item_let=A

	local title="Exit behavior"
	local defaultitem=
	local menu_choice=

	f_dialog_default_fetch defaultitem

	[ -z "${on_poweroff}" ] && on_poweroff="destroy"
	[ -z "${on_reboot}" ] && on_reboot="restart"
	[ -z "${on_crash}" ] && on_crash="destroy"

	local menu_list=""

	menu_list="${menu_list} '${item_let} on_poweroff'	'[${on_poweroff}]'	'Action to take when the guest requests a poweroff'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} on_reboot'		'[${on_reboot}]'	'Action to take when the guest requests a reboot'"
	inc_menu_index item_let
	menu_list="${menu_list} '${item_let} on_crash'		'[${on_crash}]'		'Action to take when the guest crashes'"

	menu_list="${menu_list} 'Save'	'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "$menu_choice"
	f_dialog_default_store "$menu_choice"

	return ${retval}
}


# $1 - variable to set, e.g: on_poweroff, on_reboot, on_crash
get_exit_behavior()
{
	local _input _res
	local _action="${1}"

	[ -z "${_action}" ] && return 1

	local title="Exit behaviour for ${_action}"

	local defaultitem=

	eval defaultitem="\$${_action}"

	[ -z "${defaultitem}" ] && defaultitem="destroy"

	local menu_list="
		'destroy'	'destroy'	'The domain will be terminated completely and all resources released'
		'restart'	'restart'	'The domain will be terminated and then restarted with the same configuration'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && export ${_action}="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# Submenu for exit_behavior
get_construct_exit_behavior()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_exit_behavior_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
		"-")
			continue
			;;
		"Save")
			break
			;;
		on_poweroff|on_reboot|on_crash)
			get_exit_behavior ${mychoice}
			;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}

# Submenu for xen vnc options
get_construct_xen_vnc_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_xen_vnc_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
			"-")
				continue
				;;
			"Save")
				break
				;;
			xen_vnc_tcp_bind)
				title=" vnc bind "
				prompt="default via vnc.conf: ${default_vnc_tcp_bind}\nUse 0.0.0.0 for all IPs"
				defaultitem="${xen_vnc_tcp_bind}"
				cbsd_inputbox_simple && xen_vnc_tcp_bind="${mtag}"
				;;
			xen_vnc_resolution)
				get_construct_xen_vnc_resulution_menu
				;;
			xen_vnc_vgaconf)
				get_construct_xen_vnc_vgaconf_menu
				;;
			vnc_password)
				get_construct_vnc_password
				;;
			vnc_enabled)
				# set/invert spice_enabled by old vnc_enabled values
				# since these are mutually exclusive options
				spice_enabled="${vnc_enabled}"
				invert_checkbox ${mychoice}
				if [ "${vnc_enabled}" = "1" ]; then
					spice_default="0"
				else
					spice_default="1"
				fi
				continue
				;;
			*)
				invert_checkbox ${mychoice}
				continue
				;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}

# Submenu for xen spice options
get_construct_xen_spice_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_xen_spice_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
			"-")
				continue
				;;
			"Save")
				break
				;;
			xen_spice_tcp_bind)
				title=" SPICE bind "
				prompt="default via spice.conf: ${default_spice_tcp_bind}\nUse 0.0.0.0 for all IPs"
				defaultitem="${xen_spice_tcp_bind}"
				cbsd_inputbox_simple && xen_spice_tcp_bind="${mtag}"
				;;
			xen_spice_resolution)
				get_construct_xen_spice_resulution_menu
				;;
			spice_password)
				get_construct_spice_password
				;;
			spice_enabled)
				# set/invert vnc_enabled by old spice_enabled values
				# since these are mutually exclusive options
				vnc_enabled="${spice_enabled}"
				invert_checkbox ${mychoice}
				spice_default="${spice_enabled}"
				continue
				;;
			*)
				invert_checkbox ${mychoice}
				continue
				;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}

# form for $vm_guestfs
get_construct_vm_guestfs()
{
	local _input _res

	local title="${GET_GUESTFS_MSG}"
	local defaultitem="${vm_guestfs}"

	local menu_list="
		'zfs'	'zfs'	'ZFS filesystem'
		'ufs'	'ufs'	'UFS filesystem'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_guestfs="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_boot
get_construct_vm_boot()
{
	local _res

	local vm_boot_data="${ftmpdir}/vm_boot.$$"

	bootmgmt selected=${vm_boot} controlmaster=${vm_boot_data}

	retval=$?

	case $retval in
		${DIALOG_OK})
			. ${vm_boot_data}
			;;
		*)
			;;
	esac

	/bin/rm -f ${vm_boot_data}

	return ${retval}
}

# form for $vm_efi
get_construct_vm_efi()
{
	local _input _res

	local title="${GET_EFI_MSG}"
	local defaultitem="${vm_efi}"

	local menu_list="
		'none'		'No UEFI boot'	'Legacy boot mode'
		'uefi'		'UEFI'		'Boot using UEFI firmware'
		'uefi_csm'	'UEFI CSM'	'Boot using UEFI CSM firmware'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_efi="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# update vm_\* values according to $vm_package data
# if $1 - "force", all variables will be overwrited
#  otherwise, assign variables only vm_\* is empty
# $vm_package variables must be set
apply_vm_package()
{
	[ -z "${vm_package}" ] && return 0
	[ "${1}" = "force" ] && unset vm_cpus vm_ram imgsize

	[ -z "${vm_cpus}" ] && vm_cpus=$( cbsdsql local SELECT pkg_vm_cpus FROM vmpackages WHERE name=\"${vm_package}\" )
	[ -z "${vm_ram}" ] && vm_ram=$( cbsdsql local SELECT pkg_vm_ram FROM vmpackages WHERE name=\"${vm_package}\" )
	[ -z "${imgsize}" ] && imgsize=$( cbsdsql local SELECT pkg_vm_disk FROM vmpackages WHERE name=\"${vm_package}\" )
	return 0
}

# form for $vm_package
get_construct_vm_package()
{
	local _input _res

	local title="${GET_VM_PACKAGE_MSG}"
	local defaultitem="${vm_package}"

	local sqldelimer=" "

	local menu_list=$( cbsdsql local SELECT name,pkg_vm_cpus,pkg_vm_ram,pkg_vm_disk FROM vmpackages | while read name pkg_vm_cpus pkg_vm_ram pkg_vm_disk; do
		echo "'${name}' '[${mark}] name=${name} CPU=${pkg_vm_cpus} RAM=${pkg_vm_ram} DISK=${pkg_vm_disk}'  'description'"
	done ) || err 1 "${MAGENTA}Error while create packages map${NORMAL}"

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_package="${mtag}"
			apply_vm_package force
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_console
get_construct_vm_console()
{
	local _input _res

	local title="${GET_CONSOLE_MSG}"
	local defaultitem="${vm_console}"

	local menu_list="
		'tmux'		'tmux console'			'No serial, just tmux session'
		'nmdm'		'serial console via nmdm'	'Serial console via nullmodem driver'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && vm_console="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $cd_boot_firmware
get_construct_cd_boot_firmware()
{
	local _input _res

	local title="${GET_CD_BOOT_FIRMWARE_MSG}"
	local defaultitem="${cd_boot_firmware}"

	local menu_list="
		'bhyve'		'standard bhyve firmware'	'No serial, just tmux session'
		'refind'	'reFIND firmware'		'reFIND firmware'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && cd_boot_firmware="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# form for $imgtype
get_construct_imgtype()
{
	local _input _res

	local title="${GET_IMGTYPE_MSG}"
	local defaultitem="${imgtype}"

	local menu_list="
		'zvol'		'ZFS volume'			'Use ZVOL. This is a faster bakend than md'
		'md'		'use mdconfig(8) as backend'	'Use MD if your want to have guest FS-in-file on the hoster FS'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case $retval in
		${DIALOG_OK})
			[ -n "${mtag}" ] && imgtype="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}


# form for $vm_os_type
# if $1 = "value" apply value without dialog
get_construct_vm_os_type()
{
	local _input
	local defaultitem="${vm_os_type}"
	local _vm_os_type_old="${vm_os_type}"

	if [ -n "${1}" ]; then
		vm_os_type="${1}"
		retval=${DIALOG_OK}
	else
		unset menu_list

		# load menu_list from external source by emulator opportunity
		if [ -f "${sharedir}/emulators/ostype_${emulator}.subr" ]; then
			. ${sharedir}/emulators/ostype_${emulator}.subr
		else
			f_dialog_msgbox "No such menu_list for emulator ${emulator}:\n${sharedir}/emulators/ostype_${emulator}.subr"
			return 0
		fi

		cbsd_menubox
		retval=$?
	fi

	case ${retval} in
		${DIALOG_OK})
			[ "${_vm_os_type_old}" = "${mtag}" ] && return 0		# not changed
			/bin/rm -f ${tmpdir}/get_construct_vm_os_profile.menu
			[ -n "${mtag}" ] && vm_os_type="${mtag}"
			unset vm_os_profile jname imgsize vm_ram vm_cpus cd_boot_firmware
			apply_vm_package
			# set default
			[ -z "${cd_boot_firmware}" ] && cd_boot_firmware="bhyve"
			;;
		*)
			;;
	esac

	return ${retval}
}


get_construct_vm_iso_path()
{
	local menu_list=
	local vm_res
	local i

	local title=" Select ISO "
	local prompt="${GET_VM_ISOPATH_MSG}"
	local iso_path

	vm_res=$( cbsdsql storage_media SELECT name FROM media WHERE type=\"iso\" )

	[ -z "${vm_res}" ] && return 0

	for i in ${vm_res}; do
		menu_list="${menu_list} '${i}' '${i}' '${i}'"
	done

	menu_list="${menu_list} 'Detach' 'Detach' 'Detach any CD ISO'"

	defaultitem="${vm_iso_path}"

	mtag=
	cbsd_menubox

	case $retval in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				case "${mtag}" in
					Detach)
						cbsdsql storage_media "UPDATE media SET jname='-' WHERE jname=\"${jname}\" AND type=\"iso\""
						register_iso_as=
						vm_iso_path=
						alt_iso=
						;;
					*)
						register_iso_as="${mtag}"
						vm_iso_path="${mtag}"
						alt_iso="${mtag}"
						iso_path=$( cbsdsql storage_media SELECT path FROM media WHERE type=\"iso\" AND name=\"${mtag}\" )
						# remove old disk if exist
						cbsdsql storage_media "UPDATE media SET jname='-' WHERE jname=\"${jname}\" AND type=\"iso\""
						echo "media mode=attach type=iso name=${mtag} path=${iso_path} jname=${jname}"
						media mode=attach type=iso name=${mtag} path=${iso_path} jname=${jname}
						;;
				esac
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}

get_construct_vm_cpu_topology()
{
	local menu_list=
	local vm_res
	local i
	local _query _sockets _cores _threads _vm_cores

	local title=" Select CPU topology "
	local prompt="${GET_VM_CPU_TOPOLOGY_MSG}"
	local iso_path

	vm_res=$( cbsdsql local SELECT name FROM vm_cpu_topology | /usr/bin/xargs )

	[ -z "${vm_res}" ] && return 0
	. ${strings}
	. ${distdir}/virtual.subr

	for i in ${vm_res}; do
		_query=$( cbsdsql local SELECT sockets,cores,threads FROM vm_cpu_topology WHERE name=\"${i}\" )
		[ -z "${_query}" ] && return 0
		OIFS="${IFS}"
		IFS="|"
		sqllist "${_query}" _sockets _cores _threads
		IFS="${OIFS}"
		_vm_cores=$( get_vm_cores_by_topology ${_sockets} ${_cores} ${_threads} )
		local topology_${i}_cpus="${_vm_cores}"
		menu_list="${menu_list} '${i}' 'sockets=${_sockets},cores=${_cores},threads=${_threads}' 'sockets=${_sockets},cores=${_cores},threads=${_threads}, Core: ${_vm_cores}'"
	done

	menu_list="${menu_list}"
	defaultitem="${vm_cpu_topology}"

	mtag=
	cbsd_menubox

	case ${retval} in
		${DIALOG_OK})
			if [ -n "${mtag}" ]; then
				vm_cpu_topology="${mtag}"
				eval vm_cpus="\$topology_${mtag}_cpus"
			fi
			;;
		*)
			;;
	esac

	return ${retval}
}

# try to update profiles from GitHub via Internet
get_profiles_update()
{
	local _git
	local _logfile

	_git=$( which git )

	if [ -z "${_git}" ]; then
		local msg_ok="It's a pity"
		f_dialog_msgbox "No git in system. Please install git first: pkg install -y devel/git"
		return 0
	fi

	_logfile=$( /usr/bin/mktemp )

	trap "/bin/rm -f ${_logfile}" HUP INT ABRT BUS TERM EXIT

	f_dialog_info "Updating from GitHub repository. Please wait..."
	f_dialog_title " Log messages "
	echo >> ${_logfile}
	/usr/bin/make -C ~cbsd/etc profiles-upgrade >> ${_logfile} 2>&1
	f_show_help "${_logfile}"
	/bin/rm -f ${_logfile}
	trap "" HUP INT ABRT BUS TERM EXIT
}


# form for $vm_os_profile
# if $1 not empty just load profile without dialogizing
get_construct_vm_os_profile()
{
	local _input _search_profile="vm-${vm_os_type}" _search_cloud_profile="vm-${vm_os_type}-cloud" _res vm_profile _myprofiles="" _myfile _all _num _myfile
	local menu_list cloud_menu_list _menu_list_cache
	local _cnt=0
	local _menu_list_cache=

	local title=" profile "
	local prompt="${GET_VMPROFILE_MSG}"

	# use menu item cache
	if [ -r ${tmpdir}/get_construct_vm_os_profile.menu ]; then
		#_menu_list_cache=$( /bin/cat ${tmpdir}/get_construct_vm_os_profile.menu )
		. ${tmpdir}/get_construct_vm_os_profile.menu
	else
		f_dialog_info "scan and build menu entry..."
		_menu_list_cache=
	fi

	while [ ${_cnt} -ne 1 ]; do

		menu_list=
		cloud_menu_list=
		_all=0

		if [ -z "${_menu_list_cache}" ]; then
			eval $( env NOCOLOR=1 show_profile_list search_profile=${_search_profile} show_cloud=0 show_${emulator}=1 uniq=1 display=path,name,contrib header=0 | while read path vm_profile contrib; do
				unset long_description iso_img_dist_size
				eval $( ${GREP_CMD} ^long_description= ${path} )
				eval $( ${GREP_CMD} ^iso_img_dist_size= ${path} )
				[ -z "${long_description}" ] && long_description="${vm_profile}"
				if [ -z "${iso_img_dist_size}" ]; then
					iso_img_dist_size="Unknown"
				else
					if conv2human "${iso_img_dist_size}"; then
						iso_img_dist_size=${convval}
					fi
				fi
				[ "${contrib}" = "1" ] && long_description="[contrib] ${long_description}"
				_mypath=$( echo ${path} | /usr/bin/sed s:^${workdir}/::g )
				menu_list="${menu_list} '${vm_profile}' '${_mypath}' '${long_description}, size: ${iso_img_dist_size}'"
				echo "menu_list=\"${menu_list}\""
				# store filename
				echo "profile${_all}=\"${vm_profile}\""
				echo "file${_all}=\"${path}\""
				_all=$(( _all + 1 ))
				echo "_all=${_all}"
			done )

			eval $( env NOCOLOR=1 show_profile_list search_profile=${_search_cloud_profile} show_cloud=1 show_${emulator}=1 uniq=1 display=path,name,contrib header=0 | while read path vm_profile contrib; do
				unset long_description iso_img_dist_size
				# when -n $1 we apply profile, so skip unnecessary vars
				eval $( ${GREP_CMD} ^long_description= ${path} )
				eval $( ${GREP_CMD} ^iso_img_dist_size= ${path} )
				[ -z "${long_description}" ] && long_description="${vm_profile}"
				if [ -z "${iso_img_dist_size}" ]; then
					iso_img_dist_size="Unknown"
				else
					if conv2human "${iso_img_dist_size}"; then
						iso_img_dist_size=${convval}
					fi
				fi
				[ "${contrib}" = "1" ] && long_description="[contrib] ${long_description}"
				_mypath=$( echo ${path} | /usr/bin/sed s:^${workdir}/::g )
				cloud_menu_list="${cloud_menu_list} '${vm_profile}' '${_mypath}' '${long_description}, size: ${iso_img_dist_size}'"
				echo "cloud_menu_list=\"${cloud_menu_list}\""
				# store filename
				echo "profile${_all}=\"${vm_profile}\""
				echo "file${_all}=\"${path}\""
				_all=$(( _all + 1 ))
				echo "_all=${_all}"
			done )

			if [ -n "${cloud_menu_list}" ]; then
				menu_list="${menu_list} '>' ' Cloud images ' ''"
				menu_list="${menu_list} ${cloud_menu_list}"
			fi
		else
			menu_list="${_menu_list_cache}"
			_all="${_all_cache}"
		fi

		[ -z "${menu_list}" ] && unset vm_os_profile && return 0

		# store menu item cache
		/usr/sbin/sysrc -qf ${tmpdir}/get_construct_vm_os_profile.menu _menu_list_cache="${menu_list}" > /dev/null 2>&1
		/usr/sbin/sysrc -qf ${tmpdir}/get_construct_vm_os_profile.menu _all_cache="${_all}" > /dev/null 2>&1

		if [ -n "${1}" ]; then
			mtag="${1}"
			retval=${DIALOG_OK}
		else
			defaultitem="${vm_os_profile}"
			extra_label="Update from GIT"
			cbsd_menubox_with_extra_button
			retval=$?
		fi

		case ${retval} in
			${DIALOG_OK})
				[ "${mtag}" = ">" ] && continue
				_cnt=1
				pkgnum=0
				unset pkglist tpl_pkglist from_jail vm_profile profile
				is_cloud=0
				alt_iso=
				vm_os_profile="${mtag}"
				_num=0
				_myfile=$( while [ ${_num} -ne ${_all} ]; do
					eval _myfile="\$file${_num}"
					eval _prof="\$profile${_num}"
					[ "${vm_os_profile}" = "${_prof}" ] && echo "${_myfile}" && exit
					_num=$(( _num + 1 ))
				done )

				[ -z "${_myfile}" ] && return 0

				if [ -f "${_myfile}" ]; then
					unset imgsize vm_ram vm_cpus cd_boot_firmware
					. ${_myfile}
					global_profile_file="${_myfile}"
					apply_vm_package
					# defaults
					[ -z "${cd_boot_firmware}" ] && cd_boot_firmware="bhyve"
				fi
				;;
			${DIALOG_EXTRA})
				get_profiles_update
				/bin/rm -f ${tmpdir}/get_construct_vm_os_profile.menu
				_menu_list_cache=
				continue
				;;
			*)
				_cnt=1
				return 1
				;;
		esac
	done

	vm_iso_path="${register_iso_as}"
	return ${retval}
}

# form for $profile
# if $1 not empty, just load $1 profile without dialogizing
get_construct_profile()
{
	local _input _retval _search_profile="${emulator}-freebsd-" jail_profile _res _myprofiles="" _myfile
	local _old_profile="${profile}"
	local menu_list=

	local defaultitem="${profile}"
	local title=" profile "
	local prompt="${GET_JAILPROFILE_MSG}"

	# default must be first due to last dir with user settings must overwrite
	_res=$( env NOCOLOR=1 show_profile_list show_jail=1 search_profile=${_search_profile} display=path header=0 )

	for i in ${_res}; do
		unset jail_profile
		eval $( ${GREP_CMD} ^jail_profile= ${i} )
		eval $( ${GREP_CMD} ^long_description= ${i} )
		_mypath=$( echo ${i} | /usr/bin/sed s:^${workdir}/::g )
		menu_list="${menu_list} '${jail_profile}' '${_mypath}' '${long_description}'"
		#store filename
		local file_${jail_profile}="${i}"
	done

	[ -z "${menu_list}" ] && unset jail_profile && return 0

	# unset for previous template package list
	unset tpl_pkglist

	if [ -z "${1}" ]; then
		cbsd_menubox
		case $retval in
			${DIALOG_OK})
				pkgnum=0
				unset pkglist tpl_pkglist from_jail vm_profile profile
				if [ -n "${mtag}" ]; then
					profile="${mtag}"
				else
					profile="${_old_profile}"
				fi
				;;
			*)
				;;
		esac
	else
		profile="${1}"
	fi

	eval _myfile="\$file_$profile"

	if [ -f "${_myfile}" ]; then
		. ${_myfile}
		global_profile_file="${_myfile}"
		# reload some dynamic variables depended from jname
		if [ -f ${etcdir}/${zero_profile} ]; then
			merge_apply_profiles ${global_profile_file} ${etcdir}/${zero_profile}
			merge_apply_profiles ${etcdir}/${zero_profile} ${_myfile}
		else
			merge_apply_profiles ${global_profile_file} ${etcdir}/defaults/${zero_profile}
			merge_apply_profiles ${etcdir}/defaults/${zero_profile} ${_myfile}
		fi
	fi

	# populate pkglist from tpl_pkglist if not empty
	if [ -n "${tpl_pkglist}" ]; then
		if [ -r "${tpl_pkglist}" ]; then
			# its file
			pkglist="${tpl_pkglist}"
		else
			pkglist="${ftmpdir}/tui.$$"
			trap "/bin/rm -f ${pkglist}" HUP INT ABRT BUS TERM EXIT
			for _i in ${tpl_pkglist}; do
				echo ${_i} >> ${pkglist}
			done
		fi
	fi

	return ${retval}
}


# form for $gw4
get_construct_gw4()
{
	local _input

	f_dialog_title " gw4 "

	f_dialog_input _input "${GET_GW4_MSG}" "${gw4}" \
			"${_message}" || return $?
	
	gw4="${_input}"
}


# form for $nodename
get_construct_nodename()
{
	title=" nodename "
	prompt="${nodename_msg}"
	defaultitem="${nodename}"

	cbsd_inputbox_simple && nodename="${mtag}"
}

# form for $jdomain
get_construct_jdomain()
{
	title=" jdomain "
	prompt="${jdomain_msg}"
	defaultitem="${jdomain}"

	cbsd_inputbox_simple && jdomain="${mtag}"
}


make_bhyve_part()
{
	local i _val

	if [ -n "${alt_iso}" ]; then
		iso_site=
		iso_img=
		iso_img_type=
		register_iso_name=
		register_iso_as="${alt_iso}";		# vm_os_path
	fi

/bin/cat >> ${TMPFILE} << EOF
# Bhyve minimal configuration:
#jname="${jname}";
# first disk size
imgsize="${imgsize}";
# number of vcpu
vm_cpus="${vm_cpus}";
# ram amount
vm_ram="${vm_ram}";
# profile os type
vm_os_type="${vm_os_type}";
# vm defaults/setting profile
vm_os_profile="${vm_os_profile}";
# end of Bhyve minimal configuration

#exec_start="${exec_start}"
#exec_stop="${exec_stop}"
emulator="bhyve";
# disk type - md or zvol
imgtype="${imgtype}";
# efi boot?
vm_efi="${vm_efi}";
# source site's for iso
iso_site="${iso_site}";
# iso image filename
iso_img="${iso_img}";
# iso image type?
iso_img_type="${iso_img_type}";
# register ISO as name
register_iso_name="${register_iso_name}"
# register ISO as 
register_iso_as="${register_iso_as}"
# vm hostbridge
vm_hostbridge="${vm_hostbridge}";
# additional bhyve flags
bhyve_flags="${bhyve_flags}";
# first disk type
virtio_type="${virtio_type}";
# swap size for vm-from-jail
swapsize="${swapsize}";
# path to iso image
vm_iso_path="${register_iso_as}";
# guest fs for vm-from-jail
vm_guestfs="${vm_guestfs}";
# VNC port
vm_vnc_port="${vm_vnc_port}";
# bhyve flags
bhyve_generate_acpi="${bhyve_generate_acpi}";
# bhyve flags
bhyve_wire_memory="${bhyve_wire_memory}";
# bhyve flags
bhyve_rts_keeps_utc="${bhyve_rts_keeps_utc}";
# bhyve flags
bhyve_force_msi_irq="${bhyve_force_msi_irq}";
# bhyve flags
bhyve_x2apic_mode="${bhyve_x2apic_mode}";
# bhyve flags
bhyve_mptable_gen="${bhyve_mptable_gen}";
# bhyve flags
bhyve_ignore_msr_acc="${bhyve_ignore_msr_acc}";
# wait for VNC connect when boot from CD 
cd_vnc_wait="${cd_vnc_wait}";
# VNC resolution
bhyve_vnc_resolution="${bhyve_vnc_resolution}";
# VNC bind addr
bhyve_vnc_tcp_bind="${bhyve_vnc_tcp_bind}";
# vgaconf settings
bhyve_vnc_vgaconf="${bhyve_vnc_vgaconf}";
# first NIC driver
nic_driver="${nic_driver}";
# password for VNC
vnc_password='${vnc_password}';
# automatically eject CD when boot from CD and hard-disk is not empty
media_auto_eject="${media_auto_eject}";
# cpu topology name
vm_cpu_topology="${vm_cpu_topology}";
# run via debugger
debug_engine="${debug_engine}";
# emulate xhci
xhci="${xhci}";
# use alternative boot firmware
cd_boot_firmware="${cd_boot_firmware}";
# jailed bhyve ?
jailed="${jailed}";
# custom behavior settings by exit codes
on_poweroff="${on_poweroff}";
# custom behavior settings by exit codes
on_reboot="${on_reboot}";
# custom behavior settings by exit codes
on_crash="${on_crash}";
# is cloud image?
is_cloud='${is_cloud}';
EOF

	[ ${is_cloud} -eq 0 ] && return 0
	# todo: make is generic make_cloud_init_part()
/bin/cat >> ${TMPFILE} << EOF
# cloud-init settings
ci_jname='${ci_jname}';
ci_fqdn='${ci_fqdn}';
ci_template='${ci_template}';
ci_user_pw_root_crypt='${ci_user_pw_root_crypt}';
ci_interface='${ci_interface}';
ci_ip4_addr='${ci_ip4_addr}';
ci_gw4='${ci_gw4}';
ci_nameserver_address='${ci_nameserver_address}';
ci_nameserver_search='${ci_nameserver_search}';
ci_adjust_inteface_helper='${ci_adjust_inteface_helper}';
ci_user_add='${ci_user_add}';
EOF

for i in ${ci_user_add}; do
	for _par in gecos home shell member_groups pubkey; do
		_val=
		eval _val="\$ci_user_${_par}_${i}"
		/bin/cat >> ${TMPFILE} << EOF
ci_user_${_par}_${i}='${_val}';
EOF
	done
done
}


make_virtualbox_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="${emulator}";
imgsize="${imgsize}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

vm_hostbridge="${vm_hostbridge}";
bhyve_flags="${bhyve_flags}";
virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";
with_img_helpers="";
runasap="${runasap}";
EOF
}

make_xen_part()
{
/bin/cat >> ${TMPFILE} << EOF
exec_start="${exec_start}"
exec_stop="${exec_stop}"
emulator="xen";
imgsize="${imgsize}";
vm_cpus="${vm_cpus}";
vm_ram="${vm_ram}";
vm_os_type="${vm_os_type}";
vm_efi="${vm_efi}";

iso_site="${iso_site}";
iso_img="${iso_img}";
register_iso_name="${register_iso_name}"
register_iso_as="${register_iso_as}"

virtio_type="${virtio_type}";
gw4="${gw4}";
vm_os_profile="${vm_os_profile}";
jprofile="${jprofile}";
swapsize="${swapsize}";
vm_iso_path="${register_iso_as}";
vm_guestfs="${vm_guestfs}";
vm_vnc_port="${vm_vnc_port}";

cd_vnc_wait="${cd_vnc_wait}";
xen_vnc_resolution="${xen_vnc_resolution}";
xen_vnc_tcp_bind="${xen_vnc_tcp_bind}";
vnc_password='${vnc_password}';

with_img_helpers="";
runasap="${runasap}";
nic_driver="${nic_driver}";

spice_default="${spice_default}";
xen_spice_resolution="${xen_spice_resolution}";
xen_spice_tcp_bind="${xen_spice_tcp_bind}";
spice_password='${spice_password}';

on_poweroff="${on_poweroff}";
on_reboot="${on_reboot}";
on_crash="${on_crash}";

xen_soundhw="${xen_soundhw}";
EOF
}

make_emulator_part()
{
	${SYSRC_CMD} -qf ${TMPFILE} exec_start="/usr/local/bin/${emulator} ${exec_start}" > /dev/null 2>&1
	${SYSRC_CMD} -qf ${TMPFILE} exec_stop="/usr/local/bin/${emulator} ${exec_stop}" > /dev/null 2>&1
}

make_jail_part()
{

	[ -n "${jailskeldir}" ] && ${SYSRC_CMD} -qf ${TMPFILE} jailskeldir="${jailskeldir}" > /dev/null 2>&1
	[ -n "${customskel}" ] && ${SYSRC_CMD} -qf ${TMPFILE} customskel="${customskel}" > /dev/null 2>&1
	[ -n "${jailsysskeldir}" ] && ${SYSRC_CMD} -qf ${TMPFILE} jailsysskeldir="${jailsysskeldir}" > /dev/null 2>&1

	if [ -z "${profile}" ]; then
		${SYSRC_CMD} -qf ${TMPFILE} jail_profile="default"  > /dev/null 2>&1
	else
		${SYSRC_CMD} -qf ${TMPFILE} jail_profile="${profile}"  > /dev/null 2>&1
	fi

/bin/cat >> ${TMPFILE} << EOF
mount_devfs="${mount_devfs}";
allow_mount="${allow_mount}";
allow_devfs="${allow_devfs}";
allow_nullfs="${allow_nullfs}";
allow_fusefs="${allow_fusefs}";
allow_raw_sockets="${allow_raw_sockets}";
mount_fstab="${fstab}";
arch="${arch}";
mkhostsfile="${mkhostsfile}";
devfs_ruleset="${devfs_ruleset}";
ver="${ver}";
basename="${basename}";
baserw="${baserw}";
mount_src="${mount_src}";
mount_obj="${mount_obj}";
mount_kernel="${mount_kernel}";
mount_ports="${mount_ports}";
vnet="${vnet}";
applytpl="${applytpl}";
mdsize="${mdsize}";
floatresolv="${floatresolv}";

exec_poststart="${exec_poststart}";
exec_poststop="${exec_portstop}";
exec_prestart="${exec_prestart}";
exec_prestop="${exec_prestop}";

exec_master_poststart="${exec_master_poststart}";
exec_master_poststop="${exec_master_poststop}";
exec_master_prestart="${exec_master_prestart}";
exec_master_prestop="${exec_master_prestop}";

pkg_bootstrap="${pkg_bootstrap}";
with_img_helpers="";

allow_reserved_ports="${allow_reserved_ports}";
allow_unprivileged_proc_debug="${allow_unprivileged_proc_debug}";

persist="${persist}";
childrenmax="${childrenmax}";
enforce_statfs="${enforce_statfs}";
sysrc_enable="";
EOF
	${SYSRC_CMD} -qf ${TMPFILE} exec_start="${exec_start}" > /dev/null 2>&1
	${SYSRC_CMD} -qf ${TMPFILE} exec_stop="${exec_stop}" > /dev/null 2>&1
}

# generate temp .jconf
gen_jconf()
{
	local TMPFILE="${ftmpdir}/${jname}.$$.jconf"
	local fstab="${jailfstabdir}/${jailfstabpref}${jname}"
	local rcconf="${jailrcconfdir}/rc.conf_${jname}"
	local _emulator_letter

	_emulator_letter=$( substr --pos=0 --len=1 --str=${emulator} )

	# original jail area
	/bin/cat > ${TMPFILE} << EOF
# DO NOT EDIT THIS FILE. PLEASE USE INSTEAD:
# cbsd ${_emulator_letter}config jname=${jname}
relative_path="1";
jname="${jname}";
path="${path}";
data="${data}";
rcconf="${jailrcconfdir}/rc.conf_${jname}";

# FQDN for environment
host_hostname="${host_hostname}";
# default environment IP
ip4_addr="${ip4_addr}";

# start with system boot?
astart="${astart}";

# first NIC hardware address
nic_hwaddr="${nic_hwaddr}";

# create from ZFS snapshot?
zfs_snapsrc="${zfs_snapsrc}";
# run immediately upon creation
runasap="${runasap}";
EOF

	[ -n "${interface}" ] && /bin/cat >> ${TMPFILE} <<EOF
# bind to interface
interface="${interface}";
EOF

	# additional area
	[ -n "${user_pw_root_crypt}" ] && /bin/cat >> ${TMPFILE} <<EOF
# root password
user_pw_root_crypt='${user_pw_root_crypt}';
EOF

	[ -n "${user_pw_root}" ] && /bin/cat >> ${TMPFILE} <<EOF
# root password
user_pw_root='${user_pw_root}';
EOF

	# rctl settings if set
	. ${sharedir}/rctl.conf
	for i in ${RCTL} ${RCTL_EXTRA}; do
		_val=
		eval _val="\$rctl_${i}"
		[ -n "${_val}" ] && /bin/cat >> ${TMPFILE} <<EOF
rctl_${i}="${_val}"
EOF
	done

	[ -n "${pkglist}" ] && echo "pkglist=\"${pkglist}\";" >> ${TMPFILE}

	if [ -n "${srvlist}" -a -r "${srvlist}" ]; then
		/bin/cat ${srvlist} >> ${TMPFILE}
		/bin/rm -f ${srvlist}
	fi

	if [ -n "${adduser}" -a -r "${adduser}" ]; then
		/bin/cat ${adduser} >> ${TMPFILE}
		/bin/rm -f ${adduser}
	fi
	# end of additional area

	case "${emulator}" in
		bhyve)
			make_bhyve_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd bcreate jconf=${TMPFILE}${NORMAL}"
			bcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		virtualbox)
			make_virtualbox_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd vcreate jconf=${TMPFILE}${NORMAL}"
			vcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		xen)
			make_xen_part
			getyesno "Do you want to create vm immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd xcreate jconf=${TMPFILE}${NORMAL}"
			xcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		jail)
			make_jail_part
			echo "emulator=\"${emulator}\"" >> ${TMPFILE}
			getyesno "Do you want to create jail immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd jcreate jconf=${TMPFILE}${NORMAL}"
			jcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		qemu-arm-static|qemu-mips64-static|qemu-aarch64-static)
			make_emulator_part
			echo "emulator=\"${emulator}\"" >> ${TMPFILE}
			getyesno "Do you want to create jail immediately?"
			[ $? -eq 1 -o $? -eq 3 ] && err 0 "${MAGENTA}You can make now: ${GREEN}cbsd jcreate jconf=${TMPFILE}${NORMAL}"
			jcreate jconf=${TMPFILE} delpkglist=${delpkglist} removejconf=${removejconf}
			[ $? -ne 0 ] && err 0 "${MAGENTA}Config file for jconf: ${GREEN}${TMPFILE}${NORMAL}"
			;;
		*)
			err 1 "${MAGENTA}Unsupported emulator type: ${GREEN}${emulator}${NORMAL}"
			;;
	esac

	return 0
}


merge_apply_profiles()
{
	local _out
	[ -z "${1}" ] && return 0

	local _orig="$1"; shift
	local _custom="$1"; shift
	local _i

	[ ! -f "${_orig}" ] && return 0
	if [ ! -f "${_custom}" ]; then
		. ${_orig}
		return 0
	fi

	_out=$( /usr/bin/mktemp )

	merge from=${_orig} to=${_custom} out=${_out}

	. ${_out}
	/bin/rm -f ${_out}

}

# invert boolean value for \$$1
# example: invert_checkbox $astart
invert_checkbox()
{
	[ -z "${1}" ] && return 1

	eval _mytest=\$$1
	if [ "${_mytest}" = "1" ]; then
		export ${1}=0
	else
		export ${1}=1
	fi
}

# form for $nic_hwaddr
get_construct_nic_hwaddr()
{
	. ${distdir}/vnet.subr	# ip2mac

	local tpl_ip

	if [ -n "${ip4_addr}" ]; then
		ipwmask ${ip4_addr}
		iptype ${IWM}
		if [ $? -ne 0 ]; then
			tpl_ip="${IWM}"
		else
			tpl_ip="123.234.254.192"	# random IP
		fi
	else
		tpl_ip="123.234.254.192"	# random IP
	fi

	local _input
	local _defhwaddr=$( ip2mac ${tpl_ip} )

	f_dialog_title " NIC hwaddr "

	[ -n "${nic_hwaddr}" ] && new_defhwaddr="${nic_hwaddr}"

	f_dialog_input _input "Input MAC address ( 0 - random ), eg: ${_defhwaddr}" "${new_defhwaddr}" \
		"${_message}" || return $?

	# todo: scan for dup

	[ -n "${_input}" ] && nic_hwaddr="${_input}"
}

# form for $nic_mtu
get_construct_nic_mtu()
{
	local _input

	f_dialog_title " NIC MTU. 0 - auto, inherits parent MTU "

	[ -n "${nic_hwaddr}" ] && new_defhwaddr="${nic_hwaddr}"

	f_dialog_input _input "Input MTU size ( 0 - auto ), eg: 0, 1500, 9000" "${nic_mtu}" \
		"${_message}" || return $?

	[ -n "${_input}" ] && nic_mtu="${_input}"
}

# select for xen_soundhw
# /usr/local/lib/xen/bin/qemu-system-i386 -soundhw help
get_construct_xen_soundhw()
{
	local _input _res

	local title="${GET_IMGTYPE_MSG}"
	local defaultitem="${xen_soundhw}"

	local menu_list="
		'none'		'No sound'			'Disable sound'
		'sb16'		'Creative Sound Blaster 16'	'Creative Sound Blaster 16'
		'es1370'	'ENSONIQ AudioPCI ES1370'	'ENSONIQ AudioPCI ES1370'
		'ac97'		'Intel 82801AA AC97 Audio'	'Intel 82801AA AC97 Audio'
		'adlib'		'Yamaha YM3812 (OPL2)'		'Yamaha YM3812 (OPL2)'
		'gus'		'Gravis Ultrasound GF1'		'Gravis Ultrasound GF1'
		'cs4231a'	'CS4231A'			'CS4231A'
		'hda'		'Intel HD Audio'		'Intel HD Audio'
		'pcspk'		'PC speaker'			'PC speaker'
	" # END-QUOTE

	cbsd_menubox
	retval=$?

	case ${retval} in
		${DIALOG_OK})
			[ -n "${mtag}" ] && xen_soundhw="${mtag}"
			;;
		*)
			;;
	esac

	return ${retval}
}

# Submenu for xen audio options
get_construct_xen_audio_options_menu()
{
	local _input _res item_let=A

	local title="Audio Options"
	local defaultitem=
	local menu_choice=

	f_dialog_default_fetch defaultitem

	local menu_list=""

	menu_list="${menu_list}	'${item_let} xen_soundhw'	'[${xen_soundhw}]'	'Default: ${default_xen_soundhw}'"
	menu_list="${menu_list}	'Save'				'Save changes and quit'	'Save!'"

	cbsd_menubox
	retval=$?

	f_dialog_data_sanitize menu_choice
	f_dialog_menutag_store "${menu_choice}"
	f_dialog_default_store "${menu_choice}"

	return ${retval}
}

# Submenu for xen audio options
get_construct_xen_audio_options()
{
	local mychoice index
	local old_defaultitem="${mtag}"

	while [ 1 ]; do
		get_construct_xen_audio_options_menu || break

		index=${mtag%% *}
		mychoice=${mtag##* }

		case "${mychoice}" in
			"-")
				continue
				;;
			"Save")
				break
				;;
			xen_soundhw)
				get_construct_xen_soundhw
				;;
		esac
	done

	f_dialog_default_store "${old_defaultitem}"
}

###
fi
